(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{147:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return b})),n.d(t,"rightToc",(function(){return p})),n.d(t,"default",(function(){return c}));var a=n(2),i=n(9),r=(n(0),n(151)),l={id:"frida",title:"Frida",sidebar_label:"Frida"},b={id:"frida",title:"Frida",description:"Getting started",source:"@site/docs/frida.md",permalink:"/frida",editUrl:"https://github.com/secRet-re/website/edit/master/secRet/docs/frida.md",sidebar_label:"Frida",sidebar:"someSidebar",previous:{title:"Awesome",permalink:"/awesome"},next:{title:"Dwarf",permalink:"/dwarf"}},p=[{value:"Getting started",id:"getting-started",children:[]},{value:"Global",id:"global",children:[]},{value:"console",id:"console",children:[]},{value:"rpc",id:"rpc",children:[]},{value:"Frida",id:"frida",children:[]},{value:"Script",id:"script",children:[]},{value:"Process",id:"process",children:[]},{value:"Module",id:"module",children:[]},{value:"ModuleMap",id:"modulemap",children:[]},{value:"Memory",id:"memory",children:[]},{value:"MemoryAccessMonitor",id:"memoryaccessmonitor",children:[]},{value:"Thread",id:"thread",children:[]},{value:"Int64",id:"int64",children:[]},{value:"UInt64",id:"uint64",children:[]},{value:"NativePointer",id:"nativepointer",children:[]},{value:"ArrayBuffer",id:"arraybuffer",children:[]},{value:"NativeFunction",id:"nativefunction",children:[]},{value:"NativeCallback",id:"nativecallback",children:[]},{value:"SystemFunction",id:"systemfunction",children:[]},{value:"Socket",id:"socket",children:[]},{value:"SocketListener",id:"socketlistener",children:[]},{value:"SocketConnection",id:"socketconnection",children:[]},{value:"IOStream",id:"iostream",children:[]},{value:"InputStream",id:"inputstream",children:[]},{value:"OutputStream",id:"outputstream",children:[]},{value:"UnixInputStream",id:"unixinputstream",children:[]},{value:"UnixOutputStream",id:"unixoutputstream",children:[]},{value:"Win32InputStream",id:"win32inputstream",children:[]},{value:"Win32OutputStream",id:"win32outputstream",children:[]},{value:"File",id:"file",children:[]},{value:"SqliteDatabase",id:"sqlitedatabase",children:[]},{value:"SqliteStatement",id:"sqlitestatement",children:[]},{value:"Interceptor",id:"interceptor",children:[]},{value:"Stalker",id:"stalker",children:[]},{value:"ApiResolver",id:"apiresolver",children:[]},{value:"DebugSymbol",id:"debugsymbol",children:[]},{value:"CModule",id:"cmodule",children:[{value:"Examples",id:"examples",children:[]}]},{value:"Instruction",id:"instruction",children:[]},{value:"Kernel",id:"kernel",children:[]},{value:"ObjC",id:"objc",children:[]},{value:"Java",id:"java",children:[]},{value:"WeakRef",id:"weakref",children:[]},{value:"X86Writer",id:"x86writer",children:[]},{value:"X86Relocator",id:"x86relocator",children:[]},{value:"x86 enum types",id:"x86-enum-types",children:[]},{value:"ArmWriter",id:"armwriter",children:[]},{value:"ArmRelocator",id:"armrelocator",children:[]},{value:"ThumbWriter",id:"thumbwriter",children:[]},{value:"ThumbRelocator",id:"thumbrelocator",children:[]},{value:"ARM enum types",id:"arm-enum-types",children:[]},{value:"Arm64Writer",id:"arm64writer",children:[]},{value:"Arm64Relocator",id:"arm64relocator",children:[]},{value:"AArch64 enum types",id:"aarch64-enum-types",children:[]},{value:"MipsWriter",id:"mipswriter",children:[]},{value:"MipsRelocator",id:"mipsrelocator",children:[]},{value:"MIPS enum types",id:"mips-enum-types",children:[]}],o={rightToc:p};function c(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},o,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"getting-started"},"Getting started"),Object(r.b)("p",null,"To be more productive, we highly recommend using our ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.typescriptlang.org/"}),"TypeScript"),"\nbindings. This means you get code completion, type checking, inline docs,\nrefactoring tools, etc."),Object(r.b)("p",null,"Here's a short teaser video showing the editor experience:"),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://youtu.be/9cr4gOPFN4o"}),Object(r.b)("img",Object(a.a)({parentName:"a"},{src:"https://i.ytimg.com/vi/9cr4gOPFN4o/sddefault.jpg",alt:"Frida TypeScript demo"})))),Object(r.b)("p",null,"Clone ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/oleavr/frida-agent-example"}),"this repo")," to get started."),Object(r.b)("h2",{id:"global"},"Global"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"hexdump(target[, options])"),": generate a hexdump from the provided\n",Object(r.b)("em",{parentName:"p"},"ArrayBuffer")," or ",Object(r.b)("em",{parentName:"p"},"NativePointer")," ",Object(r.b)("inlineCode",{parentName:"p"},"target"),", optionally with ",Object(r.b)("inlineCode",{parentName:"p"},"options")," for\ncustomizing the output."),Object(r.b)("p",{parentName:"li"},"For example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var libc = Module.findBaseAddress('libc.so');\nconsole.log(hexdump(libc, {\n  offset: 0,\n  length: 64,\n  header: true,\n  ansi: true\n}));\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell",metastring:"script",script:!0}),"           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF\n00000000  7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............\n00000010  03 00 28 00 01 00 00 00 00 00 00 00 34 00 00 00  ..(.........4...\n00000020  34 a8 04 00 00 00 00 05 34 00 20 00 08 00 28 00  4.......4. ...(.\n00000030  1e 00 1d 00 06 00 00 00 34 00 00 00 34 00 00 00  ........4...4...\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"int64(v)"),": short-hand for ",Object(r.b)("inlineCode",{parentName:"p"},"new Int64(v)"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"uint64(v)"),": short-hand for ",Object(r.b)("inlineCode",{parentName:"p"},"new UInt64(v)"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ptr(s)"),": short-hand for ",Object(r.b)("inlineCode",{parentName:"p"},"new NativePointer(s)"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"NULL"),": short-hand for ",Object(r.b)("inlineCode",{parentName:"p"},'ptr("0")'))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"recv([type, ]callback)"),": request ",Object(r.b)("inlineCode",{parentName:"p"},"callback")," to be called on the next\nmessage received from your Frida-based application. Optionally ",Object(r.b)("inlineCode",{parentName:"p"},"type")," may\nbe specified to only receive a message where the ",Object(r.b)("inlineCode",{parentName:"p"},"type")," field is set to\n",Object(r.b)("inlineCode",{parentName:"p"},"type"),"."),Object(r.b)("p",{parentName:"li"},"This will only give you one message, so you need to call ",Object(r.b)("inlineCode",{parentName:"p"},"recv()")," again\nto receive the next one.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"send(message[, data])"),": send the JavaScript object ",Object(r.b)("inlineCode",{parentName:"p"},"message")," to your\nFrida-based application (it must be serializable to JSON). If you also have\nsome raw binary data that you'd like to send along with it, e.g. you dumped\nsome memory using ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer#readByteArray"),", then you may pass this\nthrough the optional ",Object(r.b)("inlineCode",{parentName:"p"},"data")," argument. This requires it to either be an\nArrayBuffer or an array of integers between 0 and 255."))),Object(r.b)("div",{class:"note"},Object(r.b)("h5",null,"Performance considerations"),Object(r.b)("p",null,"While ",Object(r.b)("i",null,"send()")," is asynchronous, the total overhead of sending a single message is not optimized for high frequencies, so that means Frida leaves it up to you to batch multiple values into a single ",Object(r.b)("i",null,"send()"),"-call, based on whether low delay or high throughput is desired.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"setTimeout(func, delay[, ...parameters])"),": call ",Object(r.b)("inlineCode",{parentName:"p"},"func")," after ",Object(r.b)("inlineCode",{parentName:"p"},"delay"),"\nmilliseconds, optionally passing it one or more ",Object(r.b)("inlineCode",{parentName:"p"},"parameters"),".\nReturns an id that can be passed to ",Object(r.b)("inlineCode",{parentName:"p"},"clearTimeout")," to cancel it.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"clearTimeout(id)"),": cancel id returned by call to ",Object(r.b)("inlineCode",{parentName:"p"},"setTimeout"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"setInterval(func, delay[, ...parameters])"),": call ",Object(r.b)("inlineCode",{parentName:"p"},"func")," every ",Object(r.b)("inlineCode",{parentName:"p"},"delay"),"\nmilliseconds, optionally passing it one or more ",Object(r.b)("inlineCode",{parentName:"p"},"parameters"),".\nReturns an id that can be passed to ",Object(r.b)("inlineCode",{parentName:"p"},"clearInterval")," to cancel it.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"clearInterval(id)"),": cancel id returned by call to ",Object(r.b)("inlineCode",{parentName:"p"},"setInterval"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"setImmediate(func[, ...parameters])"),": schedules ",Object(r.b)("inlineCode",{parentName:"p"},"func")," to be called on\nFrida's JavaScript thread as soon as possible, optionally passing it one\nor more ",Object(r.b)("inlineCode",{parentName:"p"},"parameters"),".\nReturns an id that can be passed to ",Object(r.b)("inlineCode",{parentName:"p"},"clearImmediate")," to cancel it.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"clearImmediate(id)"),": cancel id returned by call to ",Object(r.b)("inlineCode",{parentName:"p"},"setImmediate"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"gc()"),": force garbage collection. Useful for testing ",Object(r.b)("inlineCode",{parentName:"p"},"WeakRef.bind()")," logic,\nbut also sometimes needed when using the Duktape runtime and its default GC\nheuristics proving a bit too lazy."))),Object(r.b)("h2",{id:"console"},"console"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"console.log(line)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"console.warn(line)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"console.error(line)"),":\nwrite ",Object(r.b)("inlineCode",{parentName:"p"},"line")," to the console of your Frida-based application. The exact\nbehavior depends on where ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/frida/frida-core"}),"frida-core"),"\nis integrated.\nFor example, this output goes to ",Object(r.b)("em",{parentName:"p"},"stdout")," or ",Object(r.b)("em",{parentName:"p"},"stderr")," when using Frida\nthrough ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/frida/frida-python"}),"frida-python"),",\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://doc.qt.io/qt-5/qdebug.html"}),"qDebug")," when using\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/frida/frida-qml"}),"frida-qml"),", etc."),Object(r.b)("p",{parentName:"li"},"Arguments that are ArrayBuffer objects will be substituted by the result of\n",Object(r.b)("inlineCode",{parentName:"p"},"hexdump()")," with default options."))),Object(r.b)("h2",{id:"rpc"},"rpc"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"rpc.exports"),": empty object that you can either replace or insert into to\nexpose an RPC-style API to your application. The key specifies the method\nname and the value is your exported function. This function may either\nreturn a plain value for returning that to the caller immediately, or a\nPromise for returning asynchronously.")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"  For example:")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"rpc.exports = {\n  add: function (a, b) {\n    return a + b;\n  },\n  sub: function (a, b) {\n    return new Promise(function (resolve) {\n      setTimeout(function () {\n        resolve(a - b);\n      }, 100);\n    });\n  }\n};\n")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"  From an application using the Node.js bindings this API would be consumed\nlike this:")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const frida = require('frida');\nconst fs = require('fs');\nconst path = require('path');\nconst util = require('util');\n\nconst readFile = util.promisify(fs.readFile);\n\nlet session, script;\nasync function run() {\n  const source = await readFile(path.join(__dirname, '_agent.js'), 'utf8');\n  session = await frida.attach('iTunes');\n  script = await session.createScript(source);\n  script.message.connect(onMessage);\n  await script.load();\n  console.log(await script.exports.add(2, 3));\n  console.log(await script.exports.sub(5, 3));\n}\n\nrun().catch(onError);\n\nfunction onError(error) {\n  console.error(error.stack);\n}\n\nfunction onMessage(message, data) {\n  if (message.type === 'send') {\n    console.log(message.payload);\n  } else if (message.type === 'error') {\n    console.error(message.stack);\n  }\n}\n")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"  The Python version would be very similar:")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"import codecs\nimport frida\n\ndef on_message(message, data):\n    if message['type'] == 'send':\n        print(message['payload'])\n    elif message['type'] == 'error':\n        print(message['stack'])\n\nsession = frida.attach('iTunes')\nwith codecs.open('./agent.js', 'r', 'utf-8') as f:\n    source = f.read()\nscript = session.create_script(source)\nscript.on('message', on_message)\nscript.load()\nprint(script.exports.add(2, 3))\nprint(script.exports.sub(5, 3))\nsession.detach()\n")),Object(r.b)("p",null,"In the example above we used ",Object(r.b)("inlineCode",{parentName:"p"},"script.on('message', on_message)")," to monitor for any messages from the injected process, JavaScript side.  There are other notifications that you can watch for as well on both the ",Object(r.b)("inlineCode",{parentName:"p"},"script")," and ",Object(r.b)("inlineCode",{parentName:"p"},"session"),".  If you want to be notified when the target process exits, use ",Object(r.b)("inlineCode",{parentName:"p"},"session.on('detached', your_function)"),"."),Object(r.b)("h2",{id:"frida"},"Frida"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Frida.version"),": property containing the current Frida version, as a string.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Frida.heapSize"),": dynamic property containing the current size of Frida's\nprivate heap, shared by all scripts and Frida's own runtime. This is useful\nfor keeping an eye on how much memory your instrumentation is using out of\nthe total consumed by the hosting process."))),Object(r.b)("h2",{id:"script"},"Script"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Script.runtime"),": string property containing the runtime being used.\nEither ",Object(r.b)("inlineCode",{parentName:"li"},"DUK")," or ",Object(r.b)("inlineCode",{parentName:"li"},"V8"),".")),Object(r.b)("h2",{id:"process"},"Process"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.id"),": property containing the PID as a number")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.arch"),": property containing the string ",Object(r.b)("inlineCode",{parentName:"p"},"ia32"),", ",Object(r.b)("inlineCode",{parentName:"p"},"x64"),", ",Object(r.b)("inlineCode",{parentName:"p"},"arm"),"\nor ",Object(r.b)("inlineCode",{parentName:"p"},"arm64"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.platform"),": property containing the string ",Object(r.b)("inlineCode",{parentName:"p"},"windows"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"darwin"),", ",Object(r.b)("inlineCode",{parentName:"p"},"linux")," or ",Object(r.b)("inlineCode",{parentName:"p"},"qnx"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.pageSize"),": property containing the size of a virtual memory page\n(in bytes) as a number. This is used to make your scripts more portable.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.pointerSize"),": property containing the size of a pointer\n(in bytes) as a number. This is used to make your scripts more portable.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.codeSigningPolicy"),": property containing the string ",Object(r.b)("inlineCode",{parentName:"p"},"optional")," or\n",Object(r.b)("inlineCode",{parentName:"p"},"required"),", where the latter means Frida will avoid modifying existing code\nin memory and will not try to run unsigned code. Currently this property\nwill always be set to ",Object(r.b)("inlineCode",{parentName:"p"},"optional")," unless you are using ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/gadget"}),"Gadget"),"\nand have configured it to assume that code-signing is required. This\nproperty allows you to determine whether the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#interceptor"}),"Interceptor")," API\nis off limits, and whether it is safe to modify code or run unsigned code.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.isDebuggerAttached()"),": returns a boolean indicating whether a\ndebugger is currently attached")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.getCurrentThreadId()"),": get this thread's OS-specific id as a number")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.enumerateThreads()"),": enumerates all threads, returning an array of\nobjects containing the following properties:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"id"),": OS-specific id"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"state"),": string specifying either ",Object(r.b)("inlineCode",{parentName:"li"},"running"),", ",Object(r.b)("inlineCode",{parentName:"li"},"stopped"),", ",Object(r.b)("inlineCode",{parentName:"li"},"waiting"),",\n",Object(r.b)("inlineCode",{parentName:"li"},"uninterruptible")," or ",Object(r.b)("inlineCode",{parentName:"li"},"halted")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"context"),": object with the keys ",Object(r.b)("inlineCode",{parentName:"li"},"pc")," and ",Object(r.b)("inlineCode",{parentName:"li"},"sp"),", which are\nNativePointer objects specifying EIP/RIP/PC and ESP/RSP/SP,\nrespectively, for ia32/x64/arm. Other processor-specific keys\nare also available, e.g. ",Object(r.b)("inlineCode",{parentName:"li"},"eax"),", ",Object(r.b)("inlineCode",{parentName:"li"},"rax"),", ",Object(r.b)("inlineCode",{parentName:"li"},"r0"),", ",Object(r.b)("inlineCode",{parentName:"li"},"x0"),", etc."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.findModuleByAddress(address)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"Process.getModuleByAddress(address)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"Process.findModuleByName(name)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"Process.getModuleByName(name)"),":\nreturns a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#module"}),"Module")," whose ",Object(r.b)("em",{parentName:"p"},"address")," or ",Object(r.b)("em",{parentName:"p"},"name")," matches the one\nspecified. In the event that no such module could be found, the\n",Object(r.b)("em",{parentName:"p"},"find"),"-prefixed functions return ",Object(r.b)("em",{parentName:"p"},"null")," whilst the ",Object(r.b)("em",{parentName:"p"},"get"),"-prefixed functions\nthrow an exception.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.enumerateModules()"),": enumerates modules loaded right now, returning\nan array of ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#module"}),"Module")," objects.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.findRangeByAddress(address)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"getRangeByAddress(address)"),":\nreturn an object with details about the range containing ",Object(r.b)("em",{parentName:"p"},"address"),". In the\nevent that no such range could be found, ",Object(r.b)("em",{parentName:"p"},"findRangeByAddress()")," returns\n",Object(r.b)("em",{parentName:"p"},"null")," whilst ",Object(r.b)("em",{parentName:"p"},"getRangeByAddress()")," throws an exception.  See\n",Object(r.b)("inlineCode",{parentName:"p"},"Process.enumerateRanges()")," for details about which fields are included.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.enumerateRanges(protection|specifier)"),": enumerates memory ranges\nsatisfying ",Object(r.b)("inlineCode",{parentName:"p"},"protection")," given as a string of the form: ",Object(r.b)("inlineCode",{parentName:"p"},"rwx"),", where ",Object(r.b)("inlineCode",{parentName:"p"},"rw-"),'\nmeans "must be at least readable and writable". Alternatively you may\nprovide a ',Object(r.b)("inlineCode",{parentName:"p"},"specifier")," object with a ",Object(r.b)("inlineCode",{parentName:"p"},"protection")," key whose value is as\naforementioned, and a ",Object(r.b)("inlineCode",{parentName:"p"},"coalesce")," key set to ",Object(r.b)("inlineCode",{parentName:"p"},"true")," if you'd like neighboring\nranges with the same protection to be coalesced (the default is ",Object(r.b)("inlineCode",{parentName:"p"},"false"),";\ni.e. keeping the ranges separate). Returns an array of objects containing\nthe following properties:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"base"),": base address as a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"size"),": size in bytes")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"protection"),": protection string (see above)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"file"),": (when available) file mapping details as an object\ncontaining:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"path"),": full filesystem path as a string"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"offset"),": offset in the mapped file on disk, in bytes"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"size"),": size in the mapped file on disk, in bytes"))))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.enumerateMallocRanges()"),": just like ",Object(r.b)("inlineCode",{parentName:"p"},"enumerateRanges()"),", but for\nindividual memory allocations known to the system heap.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Process.setExceptionHandler(callback)"),": install a process-wide exception\nhandler callback that gets a chance to handle native exceptions before the\nhosting process itself does. Called with a single argument, ",Object(r.b)("inlineCode",{parentName:"p"},"details"),", that\nis an object containing:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"type"),": string specifying one of:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"abort"),Object(r.b)("li",{parentName:"ul"},"access-violation"),Object(r.b)("li",{parentName:"ul"},"guard-page"),Object(r.b)("li",{parentName:"ul"},"illegal-instruction"),Object(r.b)("li",{parentName:"ul"},"stack-overflow"),Object(r.b)("li",{parentName:"ul"},"arithmetic"),Object(r.b)("li",{parentName:"ul"},"breakpoint"),Object(r.b)("li",{parentName:"ul"},"single-step"),Object(r.b)("li",{parentName:"ul"},"system"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"address"),": address where the exception occurred, as a NativePointer"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"memory"),": if present, is an object containing:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"operation"),": the kind of operation that triggered the exception, as\na string specifying either ",Object(r.b)("inlineCode",{parentName:"li"},"read"),", ",Object(r.b)("inlineCode",{parentName:"li"},"write"),", or ",Object(r.b)("inlineCode",{parentName:"li"},"execute")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"address"),": address that was accessed when the exception occurred, as\na NativePointer"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"context"),": object with the keys ",Object(r.b)("inlineCode",{parentName:"li"},"pc")," and ",Object(r.b)("inlineCode",{parentName:"li"},"sp"),", which are\nNativePointer objects specifying EIP/RIP/PC and ESP/RSP/SP,\nrespectively, for ia32/x64/arm. Other processor-specific keys\nare also available, e.g. ",Object(r.b)("inlineCode",{parentName:"li"},"eax"),", ",Object(r.b)("inlineCode",{parentName:"li"},"rax"),", ",Object(r.b)("inlineCode",{parentName:"li"},"r0"),", ",Object(r.b)("inlineCode",{parentName:"li"},"x0"),", etc.\nYou may also update register values by assigning to these keys."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"nativeContext"),": address of the OS and architecture-specific CPU context\nstruct, as a NativePointer. This is only exposed as a last resort for\nedge-cases where ",Object(r.b)("inlineCode",{parentName:"li"},"context")," isn't providing enough details. We would\nhowever discourage using this and rather submit a pull-request to add\nthe missing bits needed for your use-case.")),Object(r.b)("p",{parentName:"li"},"It is up to your callback to decide what to do with the exception. It could\nlog the issue, notify your application through a send() followed by a\nblocking recv() for acknowledgement of the sent data being received, or\nit can modify registers and memory to recover from the exception. You should\nreturn ",Object(r.b)("inlineCode",{parentName:"p"},"true")," if you did handle the exception, in which case Frida will\nresume the thread immediately. If you do not return ",Object(r.b)("inlineCode",{parentName:"p"},"true"),", Frida will\nforward the exception to the hosting process' exception handler, if it has\none, or let the OS terminate the process."))),Object(r.b)("h2",{id:"module"},"Module"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"Objects returned by e.g. `Module.load()` and `Process.enumerateModules()`.\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"name"),": canonical module name as a string")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"base"),": base address as a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"size"),": size in bytes")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"path"),": full filesystem path as a string")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"enumerateImports()"),": enumerates imports of module, returning an array of\nobjects containing the following properties:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"type"),": string specifying either ",Object(r.b)("inlineCode",{parentName:"li"},"function")," or ",Object(r.b)("inlineCode",{parentName:"li"},"variable")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"name"),": import name as a string"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"module"),": module name as a string"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"address"),": absolute address as a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"slot"),": memory location where the import is stored, as a\n",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer"))),Object(r.b)("p",{parentName:"li"},"Only the ",Object(r.b)("inlineCode",{parentName:"p"},"name")," field is guaranteed to be present for all imports. The\nplatform-specific backend will do its best to resolve the other fields\neven beyond what the native metadata provides, but there is no guarantee\nthat it will succeed.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"enumerateExports()"),": enumerates exports of module, returning an array\nof objects containing the following properties:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"type"),": string specifying either ",Object(r.b)("inlineCode",{parentName:"li"},"function")," or ",Object(r.b)("inlineCode",{parentName:"li"},"variable")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"name"),": export name as a string"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"address"),": absolute address as a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"enumerateSymbols()"),": enumerates symbols of module, returning an array of\nobjects containing the following properties:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"isGlobal"),": boolean specifying whether symbol is globally visible"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"type"),": string specifying one of:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"unknown"),Object(r.b)("li",{parentName:"ul"},"section"),Object(r.b)("li",{parentName:"ul"},"undefined (Mach-O)"),Object(r.b)("li",{parentName:"ul"},"absolute (Mach-O)"),Object(r.b)("li",{parentName:"ul"},"prebound-undefined (Mach-O)"),Object(r.b)("li",{parentName:"ul"},"indirect (Mach-O)"),Object(r.b)("li",{parentName:"ul"},"object (ELF)"),Object(r.b)("li",{parentName:"ul"},"function (ELF)"),Object(r.b)("li",{parentName:"ul"},"file (ELF)"),Object(r.b)("li",{parentName:"ul"},"common (ELF)"),Object(r.b)("li",{parentName:"ul"},"tls (ELF)"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"section"),": if present, is an object containing:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"id"),": string containing section index, segment name (if\napplicable) and section name \u2013 same format as\n",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"http://radare.org/r/"}),"r2"),"'s section IDs"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"protection"),": protection like in ",Object(r.b)("inlineCode",{parentName:"li"},"Process.enumerateRanges()")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"name"),": symbol name as a string"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"address"),": absolute address as a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"size"),": if present, a number specifying the symbol's size in bytes")))),Object(r.b)("div",{class:"note info"},Object(r.b)("h5",null,"enumerateSymbols() is only available on i/macOS and Linux-based OSes"),Object(r.b)("p",null,"We would love to support this on the other platforms too, so if you find this useful and would like to help out, please get in touch. You may also find the DebugSymbol API adequate, depending on your use-case.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"enumerateRanges(protection)"),": just like ",Object(r.b)("inlineCode",{parentName:"p"},"Process.enumerateRanges"),", except\nit's scoped to the module.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"findExportByName(exportName)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"getExportByName(exportName)"),": returns the absolute address of the export\nnamed ",Object(r.b)("inlineCode",{parentName:"p"},"exportName"),". In the event that no such export could be found, the\n",Object(r.b)("em",{parentName:"p"},"find"),"-prefixed function returns ",Object(r.b)("em",{parentName:"p"},"null")," whilst the ",Object(r.b)("em",{parentName:"p"},"get"),"-prefixed function\nthrows an exception."))),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Module.load(path)"),": loads the specified module from the filesystem path\nand returns a ",Object(r.b)("inlineCode",{parentName:"p"},"Module")," object. Throws an exception if the specified module\ncannot be loaded.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Module.ensureInitialized(name)"),": ensures that initializers of the specified\nmodule have been run. This is important during early instrumentation, i.e.\ncode run early in the process lifetime, to be able to safely interact with\nAPIs. One such use-case is interacting with ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#objc"}),"ObjC")," classes provided\nby a given module.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Module.findBaseAddress(name)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"Module.getBaseAddress(name)"),": returns the base address of the ",Object(r.b)("inlineCode",{parentName:"p"},"name"),"\nmodule. In the event that no such module could be found, the ",Object(r.b)("em",{parentName:"p"},"find"),"-prefixed\nfunction returns ",Object(r.b)("em",{parentName:"p"},"null")," whilst the ",Object(r.b)("em",{parentName:"p"},"get"),"-prefixed function throws an\nexception.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Module.findExportByName(moduleName|null, exportName)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"Module.getExportByName(moduleName|null, exportName)"),": returns the absolute\naddress of the export named ",Object(r.b)("inlineCode",{parentName:"p"},"exportName")," in ",Object(r.b)("inlineCode",{parentName:"p"},"moduleName"),". If the module\nisn't known you may pass ",Object(r.b)("inlineCode",{parentName:"p"},"null")," instead of its name, but this can be a\ncostly search and should be avoided. In the event that no such module or\nexport could be found, the ",Object(r.b)("em",{parentName:"p"},"find"),"-prefixed function returns ",Object(r.b)("em",{parentName:"p"},"null")," whilst\nthe ",Object(r.b)("em",{parentName:"p"},"get"),"-prefixed function throws an exception."))),Object(r.b)("h2",{id:"modulemap"},"ModuleMap"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new ModuleMap([filter])"),": create a new module map optimized for determining\nwhich module a given memory address belongs to, if any. Takes a snapshot of\nthe currently loaded modules when created, which may be refreshed by calling\n",Object(r.b)("inlineCode",{parentName:"li"},"update()"),". The ",Object(r.b)("inlineCode",{parentName:"li"},"filter")," argument is optional and allows you to pass a\nfunction used for filtering the list of modules. This is useful if you e.g.\nonly care about modules owned by the application itself, and allows you to\nquickly check if an address belongs to one of its modules. The ",Object(r.b)("inlineCode",{parentName:"li"},"filter"),"\nfunction is passed a ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#module"}),"Module")," object and must return ",Object(r.b)("inlineCode",{parentName:"li"},"true")," for\neach module that should be kept in the map. It is called for each loaded\nmodule every time the map is updated.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"has(address)"),": check if ",Object(r.b)("inlineCode",{parentName:"p"},"address")," belongs to any of the contained modules,\nand returns the result as a boolean")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"find(address)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"get(address)"),": returns a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#module"}),"Module")," with details\nabout the module that ",Object(r.b)("inlineCode",{parentName:"p"},"address")," belongs to. In the event that no such module\ncould be found, ",Object(r.b)("inlineCode",{parentName:"p"},"find()")," returns ",Object(r.b)("inlineCode",{parentName:"p"},"null")," whilst ",Object(r.b)("inlineCode",{parentName:"p"},"get()")," throws an exception.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"findName(address)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"getName(address)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"findPath(address)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"getPath(address)"),":\njust like ",Object(r.b)("inlineCode",{parentName:"p"},"find()")," and ",Object(r.b)("inlineCode",{parentName:"p"},"get()"),", but only returns the ",Object(r.b)("inlineCode",{parentName:"p"},"name")," or ",Object(r.b)("inlineCode",{parentName:"p"},"path"),"\nfield, which means less overhead when you don't need the other details.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"update()"),": update the map. You should call this after a module has been\nloaded or unloaded to avoid operating on stale data.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"values()"),": returns an array with the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#module"}),"Module")," objects currently in\nthe map. The returned array is a deep copy and will not mutate after a call\nto ",Object(r.b)("inlineCode",{parentName:"p"},"update()"),"."))),Object(r.b)("h2",{id:"memory"},"Memory"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Memory.scan(address, size, pattern, callbacks)"),": scan memory for\noccurences of ",Object(r.b)("inlineCode",{parentName:"p"},"pattern")," in the memory range given by ",Object(r.b)("inlineCode",{parentName:"p"},"address")," and ",Object(r.b)("inlineCode",{parentName:"p"},"size"),"."),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"pattern"),' must be of the form "13 37 ?? ff" to match 0x13 followed by\n0x37 followed by any byte followed by 0xff.\nFor more advanced matching it is also possible to specify an\n',Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://radare.org/r/"}),"r2"),"-style mask. The mask is bitwise AND-ed against both the needle\nand the haystack. To specify the mask append a ",Object(r.b)("inlineCode",{parentName:"p"},":"),' character after the\nneedle, followed by the mask using the same syntax.\nFor example: "13 37 13 37 : 1f ff ff f1".\nFor convenience it is also possible to specify nibble-level wildcards,\nlike "?3 37 13 ?7", which gets translated into masks behind the scenes.')),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"callbacks")," is an object with:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onMatch: function (address, size)"),": called with ",Object(r.b)("inlineCode",{parentName:"p"},"address"),"\ncontaining the address of the occurence as a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," and\n",Object(r.b)("inlineCode",{parentName:"p"},"size")," specifying the size as a number."),Object(r.b)("p",{parentName:"li"},"This function may return the string ",Object(r.b)("inlineCode",{parentName:"p"},"stop")," to cancel the memory\nscanning early.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onError: function (reason)"),": called with ",Object(r.b)("inlineCode",{parentName:"p"},"reason")," when there was a\nmemory access error while scanning")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onComplete: function ()"),": called when the memory range has been\nfully scanned"))))))),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Memory.scanSync(address, size, pattern)"),": synchronous version of ",Object(r.b)("inlineCode",{parentName:"p"},"scan()"),"\nthat returns an array of objects containing the following properties:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"address"),": absolute address as a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"size"),": size in bytes")),Object(r.b)("p",{parentName:"li"},"For example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"// Find the module for the program itself, always at index 0:\nvar m = Process.enumerateModules()[0];\n\n// Or load a module by name:\n//var m = Module.load('win32u.dll');\n\n// Print its properties:\nconsole.log(JSON.stringify(m));\n\n// Dump it from its base address:\nconsole.log(hexdump(m.base));\n\n// The pattern that you are interested in:\nvar pattern = '00 00 00 00 ?? 13 37 ?? 42';\n\nMemory.scan(m.base, m.size, pattern, {\n  onMatch: function (address, size) {\n    console.log'Memory.scan() found match at', address,\n        'with size', size);\n\n    // Optionally stop scanning early:\n    return 'stop';\n  },\n  onComplete: function () {\n    console.log('Memory.scan() complete');\n  }\n});\n\nvar results = Memory.scanSync(m.base, m.size, pattern);\nconsole.log('Memory.scanSync() result:\\n' +\n    JSON.stringify(results));\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Memory.alloc(size)"),": allocate ",Object(r.b)("inlineCode",{parentName:"p"},"size")," bytes of memory on the heap, or, if\n",Object(r.b)("inlineCode",{parentName:"p"},"size")," is a multiple of ",Object(r.b)("inlineCode",{parentName:"p"},"Process.pageSize"),", one or more raw memory pages\nmanaged by the OS. The returned value is a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," and the\nunderlying memory will be released when all JavaScript handles to it are\ngone. This means you need to keep a reference to it while the pointer is\nbeing used by code outside the JavaScript runtime.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Memory.copy(dst, src, n)"),": just like memcpy(). Returns nothing."),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"dst: a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")," specifying the destination base address."),Object(r.b)("li",{parentName:"ul"},"src: a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")," specifying the source base address."),Object(r.b)("li",{parentName:"ul"},"n: size in bytes to be copied."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Memory.dup(address, size)"),": short-hand for ",Object(r.b)("inlineCode",{parentName:"p"},"Memory.alloc()")," followed by\n",Object(r.b)("inlineCode",{parentName:"p"},"Memory.copy()"),". Returns a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," containing the base address of\nthe freshly allocated memory. See ",Object(r.b)("inlineCode",{parentName:"p"},"Memory.alloc()")," for details on the\nmemory allocation's lifetime.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Memory.protect(address, size, protection)"),": update protection on a region\nof memory, where ",Object(r.b)("inlineCode",{parentName:"p"},"protection")," is a string of the same format as\n",Object(r.b)("inlineCode",{parentName:"p"},"Process.enumerateRanges()"),"."),Object(r.b)("p",{parentName:"li"},"Returns a boolean indicating whether the operation completed successfully."),Object(r.b)("p",{parentName:"li"},"For example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"Memory.protect(ptr('0x1234'), 4096, 'rw-');\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Memory.patchCode(address, size, apply)"),": safely modify ",Object(r.b)("inlineCode",{parentName:"p"},"size")," bytes at\n",Object(r.b)("inlineCode",{parentName:"p"},"address"),", specified as a NativePointer. The supplied JavaScript function\n",Object(r.b)("inlineCode",{parentName:"p"},"apply")," gets called with a writable pointer where you must write the desired\nmodifications before returning. Do not make any assumptions about this being\nthe same location as ",Object(r.b)("inlineCode",{parentName:"p"},"address"),", as some systems require modifications to be\nwritten to a temporary location before being mapped into memory on top of\nthe original memory page (e.g. on iOS, where directly modifying in-memory\ncode may result in the process losing its CS_VALID status)."),Object(r.b)("p",{parentName:"li"},"For example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var getLivesLeft = Module.getExportByName('game-engine.so', 'get_lives_left');\nvar maxPatchSize = 64; // Do not write out of bounds, may be a temporary buffer!\nMemory.patchCode(getLivesLeft, maxPatchSize, function (code) {\n  var cw = new X86Writer(code, { pc: getLivesLeft });\n  cw.putMovRegU32('eax', 9000);\n  cw.putRet();\n  cw.flush();\n});\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Memory.allocUtf8String(str)"),",\n",Object(r.b)("inlineCode",{parentName:"li"},"Memory.allocUtf16String(str)"),",\n",Object(r.b)("inlineCode",{parentName:"li"},"Memory.allocAnsiString(str)"),":\nallocate, encode and write out ",Object(r.b)("inlineCode",{parentName:"li"},"str")," as a UTF-8/UTF-16/ANSI string on the\nheap. The returned object is a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer"),". See ",Object(r.b)("inlineCode",{parentName:"li"},"Memory#alloc")," for\ndetails about its lifetime.")),Object(r.b)("h2",{id:"memoryaccessmonitor"},"MemoryAccessMonitor"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"MemoryAccessMonitor.enable(ranges, callbacks)"),": monitor one or more memory\nranges for access, and notify on the first access of each contained memory\npage. ",Object(r.b)("inlineCode",{parentName:"p"},"ranges")," is either a single range object or an array of such objects,\neach of which contains:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"base"),": base address as a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"size"),": size in bytes")),Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"callbacks")," is an object specifying:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"onAccess: function (details)"),": called synchronously with ",Object(r.b)("inlineCode",{parentName:"li"},"details"),"\nobject containing:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"operation"),": the kind of operation that triggered the access, as a\nstring specifying either ",Object(r.b)("inlineCode",{parentName:"li"},"read"),", ",Object(r.b)("inlineCode",{parentName:"li"},"write"),", or ",Object(r.b)("inlineCode",{parentName:"li"},"execute")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"from"),": address of instruction performing the access as a\n",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"address"),": address being accessed as a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"rangeIndex"),": index of the accessed range in the ranges provided to\n",Object(r.b)("inlineCode",{parentName:"li"},"MemoryAccessMonitor.enable()")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"pageIndex"),": index of the accessed memory page inside the specified\nrange"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"pagesCompleted"),": overall number of pages which have been accessed\nso far (and are no longer being monitored)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"pagesTotal"),": overall number of pages that were initially monitored"))))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"MemoryAccessMonitor.disable()"),": stop monitoring the remaining memory ranges\npassed to ",Object(r.b)("inlineCode",{parentName:"p"},"MemoryAccessMonitor.enable()")))),Object(r.b)("h2",{id:"thread"},"Thread"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Thread.backtrace([context, backtracer])"),": generate a backtrace for the\ncurrent thread, returned as an array of ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," objects."),Object(r.b)("p",{parentName:"li"},"If you call this from Interceptor's ",Object(r.b)("inlineCode",{parentName:"p"},"onEnter")," or ",Object(r.b)("inlineCode",{parentName:"p"},"onLeave")," callbacks you\nshould provide ",Object(r.b)("inlineCode",{parentName:"p"},"this.context")," for the optional ",Object(r.b)("inlineCode",{parentName:"p"},"context")," argument, as it\nwill give you a more accurate backtrace. Omitting ",Object(r.b)("inlineCode",{parentName:"p"},"context")," means the\nbacktrace will be generated from the current stack location, which may\nnot give you a very good backtrace due to V8's stack frames.\nThe optional ",Object(r.b)("inlineCode",{parentName:"p"},"backtracer")," argument specifies the kind of backtracer to use,\nand must be either ",Object(r.b)("inlineCode",{parentName:"p"},"Backtracer.FUZZY")," or ",Object(r.b)("inlineCode",{parentName:"p"},"Backtracer.ACCURATE"),", where the\nlatter is the default if not specified. The accurate kind of backtracers\nrely on debugger-friendly binaries or presence of debug information to do a\ngood job, whereas the fuzzy backtracers perform forensics on the stack in\norder to guess the return addresses, which means you will get false\npositives, but it will work on any binary."))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var f = Module.getExportByName('libcommonCrypto.dylib',\n    'CCCryptorCreate');\nInterceptor.attach(f, {\n  onEnter: function (args) {\n    console.log('CCCryptorCreate called from:\\n' +\n        Thread.backtrace(this.context, Backtracer.ACCURATE)\n        .map(DebugSymbol.fromAddress).join('\\n') + '\\n');\n  }\n});\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Thread.sleep(delay)"),": suspend execution of the current thread for ",Object(r.b)("inlineCode",{parentName:"li"},"delay"),"\nseconds specified as a number. For example 0.05 to sleep for 50 ms.")),Object(r.b)("h2",{id:"int64"},"Int64"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new Int64(v)"),": create a new Int64 from ",Object(r.b)("inlineCode",{parentName:"li"},"v"),', which is either a number or a\nstring containing a value in decimal, or hexadecimal if prefixed with "0x".\nYou may use the ',Object(r.b)("inlineCode",{parentName:"li"},"int64(v)")," short-hand for brevity.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"add(rhs)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"sub(rhs)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"and(rhs)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"or(rhs)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"xor(rhs)"),":\nmake a new Int64 with this Int64 plus/minus/and/or/xor ",Object(r.b)("inlineCode",{parentName:"p"},"rhs"),", which may\neither be a number or another Int64")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"shr(n)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"shl(n)"),":\nmake a new Int64 with this Int64 shifted right/left by ",Object(r.b)("inlineCode",{parentName:"p"},"n")," bits")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"compare(rhs)"),": returns an integer comparison result just like\nString#localeCompare()")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"toNumber()"),": cast this Int64 to a number")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"toString([radix = 10])"),": convert to a string of optional radix (defaults to\n10)"))),Object(r.b)("h2",{id:"uint64"},"UInt64"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new UInt64(v)"),": create a new UInt64 from ",Object(r.b)("inlineCode",{parentName:"li"},"v"),', which is either a number or a\nstring containing a value in decimal, or hexadecimal if prefixed with "0x".\nYou may use the ',Object(r.b)("inlineCode",{parentName:"li"},"uint64(v)")," short-hand for brevity.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"add(rhs)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"sub(rhs)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"and(rhs)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"or(rhs)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"xor(rhs)"),":\nmake a new UInt64 with this UInt64 plus/minus/and/or/xor ",Object(r.b)("inlineCode",{parentName:"p"},"rhs"),", which may\neither be a number or another UInt64")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"shr(n)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"shl(n)"),":\nmake a new UInt64 with this UInt64 shifted right/left by ",Object(r.b)("inlineCode",{parentName:"p"},"n")," bits")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"compare(rhs)"),": returns an integer comparison result just like\nString#localeCompare()")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"toNumber()"),": cast this UInt64 to a number")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"toString([radix = 10])"),": convert to a string of optional radix (defaults to\n10)"))),Object(r.b)("h2",{id:"nativepointer"},"NativePointer"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new NativePointer(s)"),": creates a new NativePointer from the string ",Object(r.b)("inlineCode",{parentName:"li"},"s"),"\ncontaining a memory address in either decimal, or hexadecimal if prefixed\nwith '0x'. You may use the ",Object(r.b)("inlineCode",{parentName:"li"},"ptr(s)")," short-hand for brevity.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"isNull()"),": returns a boolean allowing you to conveniently check if a\npointer is NULL")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"add(rhs)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"sub(rhs)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"and(rhs)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"or(rhs)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"xor(rhs)"),":\nmakes a new NativePointer with this NativePointer plus/minus/and/or/xor\n",Object(r.b)("inlineCode",{parentName:"p"},"rhs"),", which may either be a number or another NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"shr(n)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"shl(n)"),":\nmakes a new NativePointer with this NativePointer shifted right/left by ",Object(r.b)("inlineCode",{parentName:"p"},"n"),"\nbits")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"not()"),": makes a new NativePointer with this NativePointer's bits inverted")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"sign([key, data])"),": makes a new NativePointer by taking this\nNativePointer's bits and adding pointer authentication bits, creating a\nsigned pointer. This is a no-op if the current process does not support\npointer authentication, returning this NativePointer instead of a new value."),Object(r.b)("p",{parentName:"li"},"Optionally, ",Object(r.b)("inlineCode",{parentName:"p"},"key")," may be specified as a string. Supported values are:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"ia: The IA key, for signing code pointers. This is the default."),Object(r.b)("li",{parentName:"ul"},"ib: The IB key, for signing code pointers."),Object(r.b)("li",{parentName:"ul"},"da: The DA key, for signing data pointers."),Object(r.b)("li",{parentName:"ul"},"db: The DB key, for signing data pointers.")),Object(r.b)("p",{parentName:"li"},"The ",Object(r.b)("inlineCode",{parentName:"p"},"data")," argument may also be specified as a NativePointer/number-like\nvalue to provide extra data used for the signing, and defaults to ",Object(r.b)("inlineCode",{parentName:"p"},"0"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"strip([key])"),": makes a new NativePointer by taking this NativePointer's\nbits and removing its pointer authentication bits, creating a raw pointer.\nThis is a no-op if the current process does not support pointer\nauthentication, returning this NativePointer instead of a new value."),Object(r.b)("p",{parentName:"li"},"Optionally, ",Object(r.b)("inlineCode",{parentName:"p"},"key")," may be passed to specify which key was used to sign the\npointer being stripped. Defaults to ",Object(r.b)("inlineCode",{parentName:"p"},"ia"),". (See ",Object(r.b)("inlineCode",{parentName:"p"},"sign()")," for supported\nvalues.)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"blend(smallInteger)"),": makes a new NativePointer by taking this\nNativePointer's bits and blending them with a constant, which may in turn be\npassed to ",Object(r.b)("inlineCode",{parentName:"p"},"sign()")," as ",Object(r.b)("inlineCode",{parentName:"p"},"data"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"equals(rhs)"),": returns a boolean indicating whether ",Object(r.b)("inlineCode",{parentName:"p"},"rhs")," is equal to\nthis one; i.e. it has the same pointer value")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"compare(rhs)"),": returns an integer comparison result just like\nString#localeCompare()")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"toInt32()"),": casts this NativePointer to a signed 32-bit integer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"toString([radix = 16])"),": converts to a string of optional radix (defaults\nto 16)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"toMatchPattern()"),": returns a string containing a ",Object(r.b)("inlineCode",{parentName:"p"},"Memory.scan()"),"-compatible\nmatch pattern for this pointer's raw value")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"readPointer()"),": reads a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," from this memory location."),Object(r.b)("p",{parentName:"li"},"A JavaScript exception will be thrown if the address isn't readable.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writePointer(ptr)"),": writes ",Object(r.b)("inlineCode",{parentName:"p"},"ptr")," to this memory location."),Object(r.b)("p",{parentName:"li"},"A JavaScript exception will be thrown if the address isn't writable.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"readS8()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"readU8()"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"readS16()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"readU16()"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"readS32()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"readU32()"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"readShort()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"readUShort()"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"readInt()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"readUInt()"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"readFloat()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"readDouble()"),":\nreads a signed or unsigned 8/16/32/etc. or float/double value from\nthis memory location and returns it as a number."),Object(r.b)("p",{parentName:"li"},"A JavaScript exception will be thrown if the address isn't readable.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeS8(value)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"writeU8(value)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"writeS16(value)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"writeU16(value)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"writeS32(value)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"writeU32(value)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"writeShort(value)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"writeUShort(value)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"writeInt(value)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"writeUInt(value)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"writeFloat(value)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"writeDouble(value)"),":\nwrites a signed or unsigned 8/16/32/etc. or float/double ",Object(r.b)("inlineCode",{parentName:"p"},"value")," to this\nmemory location."),Object(r.b)("p",{parentName:"li"},"A JavaScript exception will be thrown if the address isn't writable.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"readS64()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"readU64()"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"readLong()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"readULong()"),":\nreads a signed or unsigned 64-bit, or long-sized, value from this memory\nlocation and returns it as an ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#int64"}),"Int64"),"/",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#uint64"}),"UInt64")," value."),Object(r.b)("p",{parentName:"li"},"A JavaScript exception will be thrown if the address isn't readable.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeS64(value)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"writeU64(value)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"writeLong(value)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"writeULong(value)"),":\nwrites the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#int64"}),"Int64"),"/",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#uint64"}),"UInt64")," ",Object(r.b)("inlineCode",{parentName:"p"},"value")," to this memory\nlocation."),Object(r.b)("p",{parentName:"li"},"A JavaScript exception will be thrown if the address isn't writable.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"readByteArray(length)"),": reads ",Object(r.b)("inlineCode",{parentName:"p"},"length")," bytes from this memory location, and\nreturns it as an ",Object(r.b)("em",{parentName:"p"},"ArrayBuffer"),". This buffer may be efficiently transferred\nto your Frida-based application by passing it as the second argument to\n",Object(r.b)("inlineCode",{parentName:"p"},"send()"),"."),Object(r.b)("p",{parentName:"li"},"A JavaScript exception will be thrown if any of the ",Object(r.b)("inlineCode",{parentName:"p"},"length")," bytes read from\nthe address isn't readable.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeByteArray(bytes)"),": writes ",Object(r.b)("inlineCode",{parentName:"p"},"bytes")," to this memory location, where\n",Object(r.b)("inlineCode",{parentName:"p"},"bytes")," is either an ",Object(r.b)("em",{parentName:"p"},"ArrayBuffer"),", typically returned from\n",Object(r.b)("inlineCode",{parentName:"p"},"readByteArray()"),", or an array of integers between 0 and 255. For example:\n",Object(r.b)("inlineCode",{parentName:"p"},"[ 0x13, 0x37, 0x42 ]"),"."),Object(r.b)("p",{parentName:"li"},"A JavaScript exception will be thrown if any of the bytes written to\nthe address isn't writable.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"readCString([size = -1])"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"readUtf8String([size = -1])"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"readUtf16String([length = -1])"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"readAnsiString([size = -1])"),":\nreads the bytes at this memory location as an ASCII, UTF-8, UTF-16, or ANSI\nstring. Supply the optional ",Object(r.b)("inlineCode",{parentName:"p"},"size")," argument if you know the size of the\nstring in bytes, or omit it or specify ",Object(r.b)("em",{parentName:"p"},"-1")," if the string is NUL-terminated.\nLikewise you may supply the optional ",Object(r.b)("inlineCode",{parentName:"p"},"length")," argument if you know the\nlength of the string in characters."),Object(r.b)("p",{parentName:"li"},"A JavaScript exception will be thrown if any of the ",Object(r.b)("inlineCode",{parentName:"p"},"size")," / ",Object(r.b)("inlineCode",{parentName:"p"},"length")," bytes\nread from the address isn't readable."),Object(r.b)("p",{parentName:"li"},"Note that ",Object(r.b)("inlineCode",{parentName:"p"},"readAnsiString()")," is only available (and relevant) on Windows.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeUtf8String(str)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"writeUtf16String(str)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"writeAnsiString(str)"),":\nencodes and writes the JavaScript string to this memory location (with\nNUL-terminator)."),Object(r.b)("p",{parentName:"li"},"A JavaScript exception will be thrown if any of the bytes written to\nthe address isn't writable."),Object(r.b)("p",{parentName:"li"},"Note that ",Object(r.b)("inlineCode",{parentName:"p"},"writeAnsiString()")," is only available (and relevant) on Windows."))),Object(r.b)("h2",{id:"arraybuffer"},"ArrayBuffer"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"wrap(address, size)"),": creates an ArrayBuffer backed by an existing memory\nregion, where ",Object(r.b)("inlineCode",{parentName:"li"},"address")," is a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")," specifying the base address of\nthe region, and ",Object(r.b)("inlineCode",{parentName:"li"},"size")," is a number specifying its size. Unlike the\n",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")," read/write APIs, no validation is performed on access,\nmeaning a bad pointer will crash the process.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"unwrap()"),": returns a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")," specifying the base address of the\nArrayBuffer's backing store. It is the caller's responsibility to keep the\nbuffer alive while the backing store is still being used.")),Object(r.b)("h2",{id:"nativefunction"},"NativeFunction"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"new NativeFunction(address, returnType, argTypes[, abi])"),": create a new\nNativeFunction to call the function at ",Object(r.b)("inlineCode",{parentName:"p"},"address")," (specified with a\n",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer"),"), where ",Object(r.b)("inlineCode",{parentName:"p"},"returnType")," specifies the return type, and the\n",Object(r.b)("inlineCode",{parentName:"p"},"argTypes")," array specifies the argument types. You may optionally also\nspecify ",Object(r.b)("inlineCode",{parentName:"p"},"abi")," if not system default. For variadic functions, add a ",Object(r.b)("inlineCode",{parentName:"p"},"'...'"),"\nentry to ",Object(r.b)("inlineCode",{parentName:"p"},"argTypes")," between the fixed arguments and the variadic ones."),Object(r.b)("h3",Object(a.a)({parentName:"li"},{id:"structs--classes-by-value"}),"Structs & Classes by Value"),Object(r.b)("p",{parentName:"li"},"As for structs or classes passed by value, instead of a string provide an\narray containing the struct's field types following each other. You may nest\nthese as deep as desired for representing structs inside structs. Note that\nthe returned object is also a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer"),", and can thus be passed to\n",Object(r.b)("inlineCode",{parentName:"p"},"Interceptor#attach"),"."),Object(r.b)("p",{parentName:"li"},"This must match the struct/class exactly, so if you have a struct with three\nints, you must pass ",Object(r.b)("inlineCode",{parentName:"p"},"['int', 'int', 'int']"),"."),Object(r.b)("p",{parentName:"li"},"For a class that has virtual methods, the first parameter will be a pointer\nto ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Virtual_method_table"}),"the vtable"),"."),Object(r.b)("p",{parentName:"li"},"For C++ scenarios involving a return value that is larger than\n",Object(r.b)("inlineCode",{parentName:"p"},"Process.pointerSize"),", a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," to preallocated space must be passed\nin as the first parameter. (This scenario is common in WebKit, for example.)"),Object(r.b)("p",{parentName:"li"},"Example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"// LargeObject HandyClass::friendlyFunctionName();\nvar friendlyFunctionName = new NativeFunction(friendlyFunctionPtr,\n    'void', ['pointer', 'pointer']);\nvar returnValue = Memory.alloc(sizeOfLargeObject);\nfriendlyFunctionName(returnValue, thisPtr);\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"### Supported Types\n\n-   void\n-   pointer\n-   int\n-   uint\n-   long\n-   ulong\n-   char\n-   uchar\n-   float\n-   double\n-   int8\n-   uint8\n-   int16\n-   uint16\n-   int32\n-   uint32\n-   int64\n-   uint64\n-   bool\n\n### Supported ABIs\n\n-   default\n\n-   Windows 32-bit:\n    -   sysv\n    -   stdcall\n    -   thiscall\n    -   fastcall\n    -   mscdecl\n\n- Windows 64-bit:\n    -   win64\n\n- UNIX x86:\n    -   sysv\n    -   unix64\n\n- UNIX ARM:\n    -   sysv\n    -   vfp\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"new NativeFunction(address, returnType, argTypes[, options])"),": just like\nthe previous constructor, but where the fourth argument, ",Object(r.b)("inlineCode",{parentName:"p"},"options"),", is an\nobject that may contain one or more of the following keys:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"abi"),": same enum as above."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"scheduling"),": scheduling behavior as a string. Supported values are:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"cooperative: Allow other threads to execute JavaScript code while\ncalling the native function, i.e. let go of the lock\nbefore the call, and re-acquire it afterwards.\nThis is the default behavior."),Object(r.b)("li",{parentName:"ul"},"exclusive: Do not allow other threads to execute JavaScript code\nwhile calling the native function, i.e. keep holding the\nJavaScript lock.\nThis is faster but may result in deadlocks."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"exceptions"),": exception behavior as a string. Supported values are:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"steal: If the called function generates a native exception, e.g.\nby dereferencing an invalid pointer, Frida will unwind the\nstack and steal the exception, turning it into a JavaScript\nexception that can be handled. This may leave the application\nin an undefined state, but is useful to avoid crashing the\nprocess while experimenting.\nThis is the default behavior."),Object(r.b)("li",{parentName:"ul"},"propagate: Let the application deal with any native exceptions that\noccur during the function call. (Or, the handler\ninstalled through ",Object(r.b)("inlineCode",{parentName:"li"},"Process.setExceptionHandler()"),".)"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"traps"),": code traps to be enabled, as a string. Supported values are:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"default: Interceptor.attach() callbacks will be called if any hooks\nare triggered by a function call."),Object(r.b)("li",{parentName:"ul"},'all: In addition to Interceptor callbacks, Stalker may also be\ntemporarily reactivated for the duration of each function call.\nThis is useful for e.g. measuring code coverage while guiding a\nfuzzer, implementing "step into" in a debugger, etc.\nNote that this is also possible when using the ',Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#java"}),"Java"),"\nand ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#objc"}),"ObjC")," APIs, as method wrappers also provide a\n",Object(r.b)("inlineCode",{parentName:"li"},"clone(options)")," API to create a new method wrapper with custom\nNativeFunction options.")))))),Object(r.b)("h2",{id:"nativecallback"},"NativeCallback"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new NativeCallback(func, returnType, argTypes[, abi])"),": create a new\nNativeCallback implemented by the JavaScript function ",Object(r.b)("inlineCode",{parentName:"li"},"func"),", where\n",Object(r.b)("inlineCode",{parentName:"li"},"returnType")," specifies the return type, and the ",Object(r.b)("inlineCode",{parentName:"li"},"argTypes")," array specifies\nthe argument types. You may also specify the abi if not system default.\nSee ",Object(r.b)("inlineCode",{parentName:"li"},"NativeFunction")," for details about supported types and abis.\nNote that the returned object is also a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer"),", and can thus be\npassed to ",Object(r.b)("inlineCode",{parentName:"li"},"Interceptor#replace"),".\nWhen using the resulting callback with ",Object(r.b)("em",{parentName:"li"},"Interceptor.replace()"),", ",Object(r.b)("inlineCode",{parentName:"li"},"func")," will\nbe invoked with ",Object(r.b)("inlineCode",{parentName:"li"},"this")," bound to an object with some useful properties, just\nlike the one in ",Object(r.b)("em",{parentName:"li"},"Interceptor.attach()"),".")),Object(r.b)("h2",{id:"systemfunction"},"SystemFunction"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"new SystemFunction(address, returnType, argTypes[, abi])"),": just like\n",Object(r.b)("inlineCode",{parentName:"p"},"NativeFunction"),", but also provides a snapshot of the thread's last error\nstatus. The return value is an object wrapping the actual return value as\n",Object(r.b)("inlineCode",{parentName:"p"},"value"),", with one additional platform-specific field named either ",Object(r.b)("inlineCode",{parentName:"p"},"errno"),"\n(UNIX) or ",Object(r.b)("inlineCode",{parentName:"p"},"lastError")," (Windows).")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"new SystemFunction(address, returnType, argTypes[, options])"),": same as\nabove but accepting an ",Object(r.b)("inlineCode",{parentName:"p"},"options")," object like ",Object(r.b)("inlineCode",{parentName:"p"},"NativeFunction"),"'s\ncorresponding constructor."))),Object(r.b)("h2",{id:"socket"},"Socket"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Socket.listen([options])"),": open a TCP or UNIX listening socket. Returns a\n",Object(r.b)("em",{parentName:"p"},"Promise")," that receives a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#socketlistener"}),"SocketListener"),"."),Object(r.b)("p",{parentName:"li"},"Defaults to listening on both IPv4 and IPv6, if supported, and binding on\nall interfaces on a randomly selected TCP port."),Object(r.b)("p",{parentName:"li"},"The optional ",Object(r.b)("inlineCode",{parentName:"p"},"options")," argument is an object that may contain some of the\nfollowing keys:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"family"),": address family as a string. Supported values are:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"unix"),Object(r.b)("li",{parentName:"ul"},"ipv4"),Object(r.b)("li",{parentName:"ul"},"ipv6\nDefaults to listening on both ",Object(r.b)("inlineCode",{parentName:"li"},"ipv4")," and ",Object(r.b)("inlineCode",{parentName:"li"},"ipv6")," if supported."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"host"),": (IP family) IP address as a string. Defaults to all interfaces."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"port"),": (IP family) IP port as a number. Defaults to any available."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"type"),": (UNIX family) UNIX socket type as a string. Supported types are:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"anonymous"),Object(r.b)("li",{parentName:"ul"},"path"),Object(r.b)("li",{parentName:"ul"},"abstract"),Object(r.b)("li",{parentName:"ul"},"abstract-padded\nDefaults to ",Object(r.b)("inlineCode",{parentName:"li"},"path"),"."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"path"),": (UNIX family) UNIX socket path as a string."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"backlog"),": Listen backlog as a number. Defaults to ",Object(r.b)("inlineCode",{parentName:"li"},"10"),"."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Socket.connect(options)"),": connect to a TCP or UNIX server. Returns a\n",Object(r.b)("em",{parentName:"p"},"Promise")," that receives a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#socketconnection"}),"SocketConnection"),"."),Object(r.b)("p",{parentName:"li"},"The ",Object(r.b)("inlineCode",{parentName:"p"},"options")," argument is an object that should contain some of the\nfollowing keys:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"family"),": address family as a string. Supported values are:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"unix"),Object(r.b)("li",{parentName:"ul"},"ipv4"),Object(r.b)("li",{parentName:"ul"},"ipv6\nDefaults to an IP family depending on the ",Object(r.b)("inlineCode",{parentName:"li"},"host")," specified."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"host"),": (IP family) IP address as a string. Defaults to ",Object(r.b)("inlineCode",{parentName:"li"},"localhost"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"port"),": (IP family) IP port as a number."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"type"),": (UNIX family) UNIX socket type as a string. Supported types are:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"anonymous"),Object(r.b)("li",{parentName:"ul"},"path"),Object(r.b)("li",{parentName:"ul"},"abstract"),Object(r.b)("li",{parentName:"ul"},"abstract-padded\nDefaults to ",Object(r.b)("inlineCode",{parentName:"li"},"path"),"."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"path"),": (UNIX family) UNIX socket path as a string."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Socket.type(handle)"),": inspect the OS socket ",Object(r.b)("inlineCode",{parentName:"p"},"handle")," and return its type\nas a string which is either ",Object(r.b)("inlineCode",{parentName:"p"},"tcp"),", ",Object(r.b)("inlineCode",{parentName:"p"},"udp"),", ",Object(r.b)("inlineCode",{parentName:"p"},"tcp6"),", ",Object(r.b)("inlineCode",{parentName:"p"},"udp6"),", ",Object(r.b)("inlineCode",{parentName:"p"},"unix:stream"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"unix:dgram"),", or ",Object(r.b)("inlineCode",{parentName:"p"},"null")," if invalid or unknown.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Socket.localAddress(handle)"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"Socket.peerAddress(handle)"),":\ninspect the OS socket ",Object(r.b)("inlineCode",{parentName:"p"},"handle")," and return its local or peer address, or\n",Object(r.b)("inlineCode",{parentName:"p"},"null")," if invalid or unknown."),Object(r.b)("p",{parentName:"li"},"The object returned has the fields:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ip"),": (IP sockets) IP address as a string."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"port"),": (IP sockets) IP port as a number."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"path"),": (UNIX sockets) UNIX path as a string.")))),Object(r.b)("h2",{id:"socketlistener"},"SocketListener"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"All methods are fully asynchronous and return Promise objects.\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"path"),": (UNIX family) path being listened on.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"port"),": (IP family) IP port being listened on.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"close()"),": close the listener, releasing resources related to it. Once the\nlistener is closed, all other operations will fail. Closing a listener\nmultiple times is allowed and will not result in an error.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"accept()"),": wait for the next client to connect. The returned ",Object(r.b)("em",{parentName:"p"},"Promise"),"\nreceives a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#socketconnection"}),"SocketConnection"),"."))),Object(r.b)("h2",{id:"socketconnection"},"SocketConnection"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"Inherits from IOStream.\nAll methods are fully asynchronous and return Promise objects.\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"setNoDelay(noDelay)"),": disable the Nagle algorithm if ",Object(r.b)("inlineCode",{parentName:"li"},"noDelay")," is ",Object(r.b)("inlineCode",{parentName:"li"},"true"),",\notherwise enable it. The Nagle algorithm is enabled by default, so it is\nonly necessary to call this method if you wish to optimize for low delay\ninstead of high throughput.")),Object(r.b)("h2",{id:"iostream"},"IOStream"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"All methods are fully asynchronous and return Promise objects.\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"input"),": the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#inputstream"}),"InputStream")," to read from.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"output"),": the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#outputstream"}),"OutputStream")," to write to.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"close()"),": close the stream, releasing resources related to it. This will\nalso close the individual input and output streams. Once the stream is\nclosed, all other operations will fail. Closing a stream multiple times is\nallowed and will not result in an error."))),Object(r.b)("h2",{id:"inputstream"},"InputStream"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"All methods are fully asynchronous and return Promise objects.\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"close()"),": close the stream, releasing resources related to it. Once the\nstream is closed, all other operations will fail. Closing a stream multiple\ntimes is allowed and will not result in an error.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"read(size)"),": read up to ",Object(r.b)("inlineCode",{parentName:"p"},"size")," bytes from the stream. The returned\n",Object(r.b)("em",{parentName:"p"},"Promise")," receives an ",Object(r.b)("em",{parentName:"p"},"ArrayBuffer")," up to ",Object(r.b)("inlineCode",{parentName:"p"},"size")," bytes long. End of stream\nis signalled through an empty buffer.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"readAll(size)"),": keep reading from the stream until exactly ",Object(r.b)("inlineCode",{parentName:"p"},"size")," bytes\nhave been consumed. The returned ",Object(r.b)("em",{parentName:"p"},"Promise")," receives an ",Object(r.b)("em",{parentName:"p"},"ArrayBuffer")," that is\nexactly ",Object(r.b)("inlineCode",{parentName:"p"},"size")," bytes long. Premature error or end of stream results in the\n",Object(r.b)("em",{parentName:"p"},"Promise")," getting rejected with an error, where the ",Object(r.b)("inlineCode",{parentName:"p"},"Error")," object has a\n",Object(r.b)("inlineCode",{parentName:"p"},"partialData")," property containing the incomplete data."))),Object(r.b)("h2",{id:"outputstream"},"OutputStream"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"All methods are fully asynchronous and return Promise objects.\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"close()"),": close the stream, releasing resources related to it. Once the\nstream is closed, all other operations will fail. Closing a stream multiple\ntimes is allowed and will not result in an error.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"write(data)"),": try to write ",Object(r.b)("inlineCode",{parentName:"p"},"data")," to the stream. The ",Object(r.b)("inlineCode",{parentName:"p"},"data")," value is either\nan ",Object(r.b)("em",{parentName:"p"},"ArrayBuffer")," or an array of integers between 0 and 255. The returned\n",Object(r.b)("em",{parentName:"p"},"Promise")," receives a ",Object(r.b)("em",{parentName:"p"},"Number")," specifying how many bytes of ",Object(r.b)("inlineCode",{parentName:"p"},"data")," were\nwritten to the stream.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeAll(data)"),": keep writing to the stream until all of ",Object(r.b)("inlineCode",{parentName:"p"},"data")," has been\nwritten. The ",Object(r.b)("inlineCode",{parentName:"p"},"data")," value is either an ",Object(r.b)("em",{parentName:"p"},"ArrayBuffer")," or an array of integers\nbetween 0 and 255. Premature error or end of stream results in an error,\nwhere the ",Object(r.b)("inlineCode",{parentName:"p"},"Error")," object has a ",Object(r.b)("inlineCode",{parentName:"p"},"partialSize")," property specifying how many\nbytes of ",Object(r.b)("inlineCode",{parentName:"p"},"data")," were written to the stream before the error occurred."))),Object(r.b)("h2",{id:"unixinputstream"},"UnixInputStream"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"(Only available on UNIX-like OSes.)\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"new UnixInputStream(fd[, options])"),": create a new\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#inputstream"}),"InputStream")," from the specified file descriptor ",Object(r.b)("inlineCode",{parentName:"p"},"fd"),"."),Object(r.b)("p",{parentName:"li"},"You may also supply an ",Object(r.b)("inlineCode",{parentName:"p"},"options")," object with ",Object(r.b)("inlineCode",{parentName:"p"},"autoClose")," set to ",Object(r.b)("inlineCode",{parentName:"p"},"true")," to\nmake the stream close the underlying file descriptor when the stream is\nreleased, either through ",Object(r.b)("inlineCode",{parentName:"p"},"close()")," or future garbage-collection."))),Object(r.b)("h2",{id:"unixoutputstream"},"UnixOutputStream"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"(Only available on UNIX-like OSes.)\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"new UnixOutputStream(fd[, options])"),": create a new\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#outputstream"}),"OutputStream")," from the specified file descriptor ",Object(r.b)("inlineCode",{parentName:"p"},"fd"),"."),Object(r.b)("p",{parentName:"li"},"You may also supply an ",Object(r.b)("inlineCode",{parentName:"p"},"options")," object with ",Object(r.b)("inlineCode",{parentName:"p"},"autoClose")," set to ",Object(r.b)("inlineCode",{parentName:"p"},"true")," to\nmake the stream close the underlying file descriptor when the stream is\nreleased, either through ",Object(r.b)("inlineCode",{parentName:"p"},"close()")," or future garbage-collection."))),Object(r.b)("h2",{id:"win32inputstream"},"Win32InputStream"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"(Only available on Windows.)\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"new Win32InputStream(handle[, options])"),": create a new\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#inputstream"}),"InputStream")," from the specified ",Object(r.b)("inlineCode",{parentName:"p"},"handle"),", which is a Windows\n",Object(r.b)("em",{parentName:"p"},"HANDLE")," value."),Object(r.b)("p",{parentName:"li"},"You may also supply an ",Object(r.b)("inlineCode",{parentName:"p"},"options")," object with ",Object(r.b)("inlineCode",{parentName:"p"},"autoClose")," set to ",Object(r.b)("inlineCode",{parentName:"p"},"true")," to\nmake the stream close the underlying handle when the stream is released,\neither through ",Object(r.b)("inlineCode",{parentName:"p"},"close()")," or future garbage-collection."))),Object(r.b)("h2",{id:"win32outputstream"},"Win32OutputStream"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"(Only available on Windows.)\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"new Win32OutputStream(handle[, options])"),": create a new\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#outputstream"}),"OutputStream")," from the specified ",Object(r.b)("inlineCode",{parentName:"p"},"handle"),", which is a\nWindows ",Object(r.b)("em",{parentName:"p"},"HANDLE")," value."),Object(r.b)("p",{parentName:"li"},"You may also supply an ",Object(r.b)("inlineCode",{parentName:"p"},"options")," object with ",Object(r.b)("inlineCode",{parentName:"p"},"autoClose")," set to ",Object(r.b)("inlineCode",{parentName:"p"},"true")," to\nmake the stream close the underlying handle when the stream is released,\neither through ",Object(r.b)("inlineCode",{parentName:"p"},"close()")," or future garbage-collection."))),Object(r.b)("h2",{id:"file"},"File"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new File(filePath, mode)"),": open or create the file at ",Object(r.b)("inlineCode",{parentName:"li"},"filePath")," with\nthe ",Object(r.b)("inlineCode",{parentName:"li"},"mode")," string specifying how it should be opened. For example ",Object(r.b)("inlineCode",{parentName:"li"},'"wb"'),"\nto open the file for writing in binary mode (this is the same format as\n",Object(r.b)("inlineCode",{parentName:"li"},"fopen()")," from the C standard library).")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"write(data)"),": synchronously write ",Object(r.b)("inlineCode",{parentName:"p"},"data")," to the file, where ",Object(r.b)("inlineCode",{parentName:"p"},"data")," is\neither a string or a buffer as returned by ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer#readByteArray"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"flush()"),": flush any buffered data to the underlying file")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"close()"),": close the file. You should call this function when you're done\nwith the file unless you are fine with this happening when the object is\ngarbage-collected or the script is unloaded."))),Object(r.b)("h2",{id:"sqlitedatabase"},"SqliteDatabase"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"SqliteDatabase.open(path[, options])"),": opens the SQLite v3 database\nspecified by ",Object(r.b)("inlineCode",{parentName:"p"},"path"),", a string containing the filesystem path to the\ndatabase. By default the database will be opened read-write, but you may\ncustomize this behavior by providing an ",Object(r.b)("inlineCode",{parentName:"p"},"options")," object with a property\nnamed ",Object(r.b)("inlineCode",{parentName:"p"},"flags"),", specifying an array of strings containing one or more of the\nfollowing values: ",Object(r.b)("inlineCode",{parentName:"p"},"readonly"),", ",Object(r.b)("inlineCode",{parentName:"p"},"readwrite"),", ",Object(r.b)("inlineCode",{parentName:"p"},"create"),".  The returned\nSqliteDatabase object will allow you to perform queries on the database.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"SqliteDatabase.openInline(encodedContents)"),": just like ",Object(r.b)("inlineCode",{parentName:"p"},"open()")," but the\ncontents of the database is provided as a string containing its data,\nBase64-encoded. We recommend gzipping the database before Base64-encoding\nit, but this is optional and detected by looking for a gzip magic marker.\nThe database is opened read-write, but is 100% in-memory and never touches\nthe filesystem. This is useful for agents that need to bundle a cache of\nprecomputed data, e.g. static analysis data used to guide dynamic analysis."))),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"close()"),": close the database. You should call this function when you're\ndone with the database, unless you are fine with this happening when the\nobject is garbage-collected or the script is unloaded.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"exec(sql)"),": execute a raw SQL query, where ",Object(r.b)("inlineCode",{parentName:"p"},"sql")," is a string containing\nthe text-representation of the query. The query's result is ignored, so this\nshould only be used for queries for setting up the database, e.g. table\ncreation.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"prepare(sql)"),": compile the provided SQL into a\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#sqlitestatement"}),"SqliteStatement")," object, where ",Object(r.b)("inlineCode",{parentName:"p"},"sql")," is a string\ncontaining the text-representation of the query."),Object(r.b)("p",{parentName:"li"},"For example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var db, smt, row, name, bio;\n\ndb = SqliteDatabase.open('/path/to/people.db');\n\nsmt = db.prepare('SELECT name, bio FROM people WHERE age = ?');\n\nconsole.log('People whose age is 42:');\nsmt.bindInteger(1, 42);\nwhile ((row = smt.step()) !== null) {\n  name = row[0];\n  bio = row[1];\n  console.log('Name:', name);\n  console.log('Bio:', bio);\n}\nsmt.reset();\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"dump()"),": dump the database to a gzip-compressed blob encoded as Base64,\nwhere the result is returned as a string. This is useful for inlining a\ncache in your agent's code, loaded by calling ",Object(r.b)("inlineCode",{parentName:"li"},"SqliteDatabase.openInline()"),".")),Object(r.b)("h2",{id:"sqlitestatement"},"SqliteStatement"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"bindInteger(index, value)"),": bind the integer ",Object(r.b)("inlineCode",{parentName:"li"},"value")," to ",Object(r.b)("inlineCode",{parentName:"li"},"index")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"bindFloat(index, value)"),": bind the floating point ",Object(r.b)("inlineCode",{parentName:"li"},"value")," to ",Object(r.b)("inlineCode",{parentName:"li"},"index")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"bindText(index, value)"),": bind the text ",Object(r.b)("inlineCode",{parentName:"li"},"value")," to ",Object(r.b)("inlineCode",{parentName:"li"},"index")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"bindBlob(index, bytes)"),": bind the blob ",Object(r.b)("inlineCode",{parentName:"li"},"bytes")," to ",Object(r.b)("inlineCode",{parentName:"li"},"index"),", where ",Object(r.b)("inlineCode",{parentName:"li"},"bytes"),"\nis an ArrayBuffer, array of byte values, or a string"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"bindNull(index)"),": bind a null value to ",Object(r.b)("inlineCode",{parentName:"li"},"index")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"step()"),": either start a new query and get the first result, or move to the\nnext one. Returns an array containing the values in the order specified by\nthe query, or ",Object(r.b)("inlineCode",{parentName:"li"},"null")," when the last result is reached. You should call\n",Object(r.b)("inlineCode",{parentName:"li"},"reset()")," at that point if you intend to use this object again."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"reset()"),": reset internal state to allow subsequent queries")),Object(r.b)("h2",{id:"interceptor"},"Interceptor"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Interceptor.attach(target, callbacks[, data])"),": intercept calls to function\nat ",Object(r.b)("inlineCode",{parentName:"p"},"target"),". This is a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," specifying the address of the\nfunction you would like to intercept calls to. Note that on 32-bit ARM this\naddress must have its least significant bit set to 0 for ARM functions, and\n1 for Thumb functions. Frida takes care of this detail for you if you get\nthe address from a Frida API (for example ",Object(r.b)("inlineCode",{parentName:"p"},"Module.getExportByName()"),")."),Object(r.b)("p",{parentName:"li"},"The ",Object(r.b)("inlineCode",{parentName:"p"},"callbacks")," argument is an object containing one or more of:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onEnter: function (args)"),": callback function given one argument\n",Object(r.b)("inlineCode",{parentName:"p"},"args")," that can be used to read or write arguments as an array of\n",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," objects.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onLeave: function (retval)"),": callback function given one argument\n",Object(r.b)("inlineCode",{parentName:"p"},"retval")," that is a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer"),"-derived object containing the raw\nreturn value.\nYou may call ",Object(r.b)("inlineCode",{parentName:"p"},"retval.replace(1337)")," to replace the return value with\nthe integer ",Object(r.b)("inlineCode",{parentName:"p"},"1337"),", or ",Object(r.b)("inlineCode",{parentName:"p"},'retval.replace(ptr("0x1234"))')," to replace with\na pointer.\nNote that this object is recycled across ",Object(r.b)("em",{parentName:"p"},"onLeave")," calls, so do not\nstore and use it outside your callback. Make a deep copy if you need\nto store the contained value, e.g.: ",Object(r.b)("inlineCode",{parentName:"p"},"ptr(retval.toString())"),"."))),Object(r.b)("p",{parentName:"li"},"In case the hooked function is very hot, ",Object(r.b)("inlineCode",{parentName:"p"},"onEnter")," and ",Object(r.b)("inlineCode",{parentName:"p"},"onLeave")," may be\n",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," values pointing at native C functions compiled using\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#cmodule"}),"CModule"),". Their signatures are:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"void onEnter (GumInvocationContext * ic)"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"void onLeave (GumInvocationContext * ic)")))),Object(r.b)("p",{parentName:"li"},"In such cases, the third optional argument ",Object(r.b)("inlineCode",{parentName:"p"},"data")," may be a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer"),"\naccessible through ",Object(r.b)("inlineCode",{parentName:"p"},"gum_invocation_context_get_listener_function_data()"),"."),Object(r.b)("p",{parentName:"li"},"You may also intercept arbitrary instructions by passing a function instead\nof the ",Object(r.b)("inlineCode",{parentName:"p"},"callbacks")," object. This function has the same signature as\n",Object(r.b)("inlineCode",{parentName:"p"},"onEnter"),", but the ",Object(r.b)("inlineCode",{parentName:"p"},"args")," argument passed to it will only give you sensible\nvalues if the intercepted instruction is at the beginning of a function or\nat a point where registers/stack have not yet deviated from that point."),Object(r.b)("p",{parentName:"li"},"Just like above, this function may also be implemented in C by specifying\na ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," instead of a function."),Object(r.b)("p",{parentName:"li"},"Returns a listener object that you can call ",Object(r.b)("inlineCode",{parentName:"p"},"detach()")," on."),Object(r.b)("p",{parentName:"li"},"Note that these functions will be invoked with ",Object(r.b)("inlineCode",{parentName:"p"},"this")," bound to a\nper-invocation (thread-local) object where you can store arbitrary data,\nwhich is useful if you want to read an argument in ",Object(r.b)("inlineCode",{parentName:"p"},"onEnter")," and act on it\nin ",Object(r.b)("inlineCode",{parentName:"p"},"onLeave"),"."),Object(r.b)("p",{parentName:"li"},"For example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"Interceptor.attach(Module.getExportByName('libc.so', 'read'), {\n  onEnter: function (args) {\n    this.fileDescriptor = args[0].toInt32();\n  },\n  onLeave: function (retval) {\n    if (retval.toInt32() > 0) {\n      /* do something with this.fileDescriptor */\n    }\n  }\n});\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Additionally, the object contains some useful properties:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"returnAddress"),": return address as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"context"),": object with the keys ",Object(r.b)("inlineCode",{parentName:"p"},"pc")," and ",Object(r.b)("inlineCode",{parentName:"p"},"sp"),", which are\nNativePointer objects specifying EIP/RIP/PC and ESP/RSP/SP,\nrespectively, for ia32/x64/arm. Other processor-specific keys\nare also available, e.g. ",Object(r.b)("inlineCode",{parentName:"p"},"eax"),", ",Object(r.b)("inlineCode",{parentName:"p"},"rax"),", ",Object(r.b)("inlineCode",{parentName:"p"},"r0"),", ",Object(r.b)("inlineCode",{parentName:"p"},"x0"),", etc.\nYou may also update register values by assigning to these keys.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"errno"),": (UNIX) current errno value (you may replace it)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"lastError"),": (Windows) current OS error value (you may replace it)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"threadId"),": OS thread ID")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"depth"),": call depth of relative to other invocations"))),Object(r.b)("p",{parentName:"li"},"For example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"Interceptor.attach(Module.getExportByName(null, 'read'), {\n  onEnter: function (args) {\n    console.log('Context information:');\n    console.log('Context  : ' + JSON.stringify(this.context));\n    console.log('Return   : ' + this.returnAddress);\n    console.log('ThreadId : ' + this.threadId);\n    console.log('Depth    : ' + this.depth);\n    console.log('Errornr  : ' + this.err);\n\n    // Save arguments for processing in onLeave.\n    this.fd = args[0].toInt32();\n    this.buf = args[1];\n    this.count = args[2].toInt32();\n  },\n  onLeave: function (result) {\n    console.log('----------')\n    // Show argument 1 (buf), saved during onEnter.\n    var numBytes = result.toInt32();\n    if (numBytes > 0) {\n      console.log(hexdump(this.buf, { length: numBytes, ansi: true }));\n    }\n    console.log('Result   : ' + numBytes);\n  }\n})\n")),Object(r.b)("div",{class:"note"},Object(r.b)("h5",null,"Performance considerations"),Object(r.b)("p",null,"The callbacks provided have a significant impact on performance. If you only need to inspect arguments but do not care about the return value, or the other way around, make sure you omit the callback that you don't need; i.e. avoid putting your logic in ",Object(r.b)("i",null,"onEnter")," and leaving ",Object(r.b)("i",null,"onLeave")," in there as an empty callback."),Object(r.b)("p",null,"On an iPhone 5S the base overhead when providing just ",Object(r.b)("i",null,"onEnter")," might be something like 6 microseconds, and 11 microseconds with both ",Object(r.b)("i",null,"onEnter"),"and ",Object(r.b)("i",null,"onLeave")," provided."),Object(r.b)("p",null,"Also be careful about intercepting calls to functions that are called a bazillion times per second; while ",Object(r.b)("i",null,"send()")," is asynchronous, the total overhead of sending a single message is not optimized for high frequencies, so that means Frida leaves it up to you to batch multiple values into a single ",Object(r.b)("i",null,"send()"),"-call, based on whether low delay or high throughput is desired."),Object(r.b)("p",null,"However when hooking hot functions you may use Interceptor in conjunction with CModule to implement the callbacks in C.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Interceptor.detachAll()"),": detach all previously attached callbacks.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Interceptor.replace(target, replacement[, data])"),": replace function at\n",Object(r.b)("inlineCode",{parentName:"p"},"target")," with implementation at ",Object(r.b)("inlineCode",{parentName:"p"},"replacement"),". This is typically used if you\nwant to fully or partially replace an existing function's implementation."),Object(r.b)("p",{parentName:"li"},"Use ",Object(r.b)("inlineCode",{parentName:"p"},"NativeCallback")," to implement a ",Object(r.b)("inlineCode",{parentName:"p"},"replacement")," in JavaScript."),Object(r.b)("p",{parentName:"li"},"In case the replaced function is very hot, you may implement ",Object(r.b)("inlineCode",{parentName:"p"},"replacement"),"\nin C using ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#cmodule"}),"CModule"),". You may then also specify the third optional\nargument ",Object(r.b)("inlineCode",{parentName:"p"},"data"),", which is a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," accessible through\n",Object(r.b)("inlineCode",{parentName:"p"},"gum_invocation_context_get_listener_function_data()"),". Use\n",Object(r.b)("inlineCode",{parentName:"p"},"gum_interceptor_get_current_invocation()")," to get hold of the\n",Object(r.b)("inlineCode",{parentName:"p"},"GumInvocationContext *"),"."),Object(r.b)("p",{parentName:"li"},"Note that ",Object(r.b)("inlineCode",{parentName:"p"},"replacement")," will be kept alive until ",Object(r.b)("inlineCode",{parentName:"p"},"Interceptor#revert")," is\ncalled."),Object(r.b)("p",{parentName:"li"},"If you want to chain to the original implementation you can synchronously\ncall ",Object(r.b)("inlineCode",{parentName:"p"},"target")," through a ",Object(r.b)("inlineCode",{parentName:"p"},"NativeFunction")," inside your implementation, which\nwill bypass and go directly to the original implementation."),Object(r.b)("p",{parentName:"li"},"Here's an example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var openPtr = Module.getExportByName('libc.so', 'open');\nvar open = new NativeFunction(openPtr, 'int', ['pointer', 'int']);\nInterceptor.replace(openPtr, new NativeCallback(function (pathPtr, flags) {\n  var path = pathPtr.readUtf8String();\n  log('Opening \"' + path + '\"');\n  var fd = open(pathPtr, flags);\n  log('Got fd: ' + fd);\n  return fd;\n}, 'int', ['pointer', 'int']));\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Interceptor.revert(target)"),": revert function at ",Object(r.b)("inlineCode",{parentName:"p"},"target")," to the previous\nimplementation.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Interceptor.flush()"),": ensure any pending changes have been committed\nto memory. This is should only be done in the few cases where this is\nnecessary, e.g. if you just attach()ed to or replace()d a function that you\nare about to call using ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#nativefunction"}),"NativeFunction"),". Pending changes\nare flushed automatically whenever the current thread is about to leave the\nJavaScript runtime or calls send(). This includes any API built on top of\nsend(), like when returning from an ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#rpc"}),"RPC")," method, and calling any\nmethod on the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#console"}),"console")," API."))),Object(r.b)("h2",{id:"stalker"},"Stalker"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Stalker.exclude(range)"),": marks the specified memory ",Object(r.b)("inlineCode",{parentName:"p"},"range")," as excluded,\nwhich is an object with ",Object(r.b)("inlineCode",{parentName:"p"},"base")," and ",Object(r.b)("inlineCode",{parentName:"p"},"size")," properties \u2013 like the properties\nin an object returned by e.g. ",Object(r.b)("inlineCode",{parentName:"p"},"Process.getModuleByName()"),"."),Object(r.b)("p",{parentName:"li"},"This means Stalker will not follow execution when encountering a call to an\ninstruction in such a range. You will thus be able to observe/modify the\narguments going in, and the return value coming back, but won't see the\ninstructions that happened between."),Object(r.b)("p",{parentName:"li"},"Useful to improve performance and reduce noise.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Stalker.follow([threadId, options])"),": start stalking ",Object(r.b)("inlineCode",{parentName:"p"},"threadId")," (or the\ncurrent thread if omitted), optionally with ",Object(r.b)("inlineCode",{parentName:"p"},"options")," for enabling events."),Object(r.b)("p",{parentName:"li"},"For example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const mainThread = Process.enumerateThreads()[0];\n\nStalker.follow(mainThread.id, {\n  events: {\n    call: true, // CALL instructions: yes please\n\n    // Other events:\n    ret: false, // RET instructions\n    exec: false, // all instructions: not recommended as it's\n                 //                   a lot of data\n    block: false, // block executed: coarse execution trace\n    compile: false // block compiled: useful for coverage\n  },\n\n  //\n  // Only specify one of the two following callbacks.\n  // (See note below.)\n  //\n\n  //\n  // onReceive: Called with `events` containing a binary blob\n  //            comprised of one or more GumEvent structs.\n  //            See `gumevent.h` for details about the\n  //            format. Use `Stalker.parse()` to examine the\n  //            data.\n  //\n  //onReceive: function (events) {\n  //},\n  //\n\n  //\n  // onCallSummary: Called with `summary` being a key-value\n  //                mapping of call target to number of\n  //                calls, in the current time window. You\n  //                would typically implement this instead of\n  //                `onReceive()` for efficiency, i.e. when\n  //                you only want to know which targets were\n  //                called and how many times, but don't care\n  //                about the order that the calls happened\n  //                in.\n  //\n  onCallSummary: function (summary) {\n  },\n\n  //\n  // Advanced users: This is how you can plug in your own\n  //                 StalkerTransformer, where the provided\n  //                 function is called synchronously\n  //                 whenever Stalker wants to recompile\n  //                 a basic block of the code that's about\n  //                 to be executed by the stalked thread.\n  //\n  //transform: function (iterator) {\n  //  var instruction = iterator.next();\n  //\n  //  var startAddress = instruction.address;\n  //  var isAppCode = startAddress.compare(appStart) >= 0 &&\n  //      startAddress.compare(appEnd) === -1;\n  //\n  //  do {\n  //    if (isAppCode && instruction.mnemonic === 'ret') {\n  //      iterator.putCmpRegI32('eax', 60);\n  //      iterator.putJccShortLabel('jb', 'nope', 'no-hint');\n  //\n  //      iterator.putCmpRegI32('eax', 90);\n  //      iterator.putJccShortLabel('ja', 'nope', 'no-hint');\n  //\n  //      iterator.putCallout(onMatch);\n  //\n  //      iterator.putLabel('nope');\n  //    }\n  //\n  //    iterator.keep();\n  //  } while ((instruction = iterator.next()) !== null);\n  //},\n  //\n  // The default implementation is just:\n  //\n  //   while (iterator.next() !== null)\n  //     iterator.keep();\n  //\n  // The example above shows how you can insert your own code\n  // just before every `ret` instruction across any code\n  // executed by the stalked thread inside the app's own\n  // memory range. It inserts code that checks if the `eax`\n  // register contains a value between 60 and 90, and inserts\n  // a synchronous callout back into JavaScript whenever that\n  // is the case. The callback receives a single argument\n  // that gives it access to the CPU registers, and it is\n  // also able to modify them.\n  //\n  // function onMatch (context) {\n  //   console.log('Match! pc=' + context.pc +\n  //       ' rax=' + context.rax.toInt32());\n  // }\n  //\n  // Note that not calling keep() will result in the\n  // instruction getting dropped, which makes it possible\n  // for your transform to fully replace certain instructions\n  // when this is desirable.\n  //\n\n  //\n  // Want better performance? Write the callbacks in C:\n  //\n  // /*\n  //  * const cm = new CModule(\\`\n  //  *\n  //  * #include <gum/gumstalker.h>\n  //  *\n  //  * static void on_ret (GumCpuContext * cpu_context,\n  //  *     gpointer user_data);\n  //  *\n  //  * void\n  //  * transform (GumStalkerIterator * iterator,\n  //  *            GumStalkerOutput * output,\n  //  *            gpointer user_data)\n  //  * {\n  //  *   cs_insn * insn;\n  //  *\n  //  *   while (gum_stalker_iterator_next (iterator, &insn))\n  //  *   {\n  //  *     if (insn->id == X86_INS_RET)\n  //  *     {\n  //  *       gum_x86_writer_put_nop (output->writer.x86);\n  //  *       gum_stalker_iterator_put_callout (iterator,\n  //  *           on_ret, NULL, NULL);\n  //  *     }\n  //  *\n  //  *     gum_stalker_iterator_keep (iterator);\n  //  *   }\n  //  * }\n  //  *\n  //  * static void\n  //  * on_ret (GumCpuContext * cpu_context,\n  //  *         gpointer user_data)\n  //  * {\n  //  *   printf (\"on_ret!\\n\");\n  //  * }\n  //  *\n  //  * `);\n  //  */\n  //\n  //transform: cm.transform,\n  //data: ptr(1337) /* user_data */\n  //\n  // You may also use a hybrid approach and only write\n  // some of the callouts in C.\n  //\n});\n")),Object(r.b)("div",{class:"note"},Object(r.b)("h5",null,"Performance considerations"),Object(r.b)("p",null,"The callbacks provided have a significant impact on performance. If you only need periodic call summaries but do not care about the raw events, or the other way around, make sure you omit the callback that you don't need; i.e. avoid putting your logic in ",Object(r.b)("i",null,"onCallSummary")," and leaving",Object(r.b)("i",null,"onReceive")," in there as an empty callback."),Object(r.b)("p",null,"Also note that Stalker may be used in conjunction with CModule, which means the callbacks may be implemented in C.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Stalker.unfollow([threadId])"),": stop stalking ",Object(r.b)("inlineCode",{parentName:"p"},"threadId")," (or the current\nthread if omitted).")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Stalker.parse(events[, options])"),": parse GumEvent binary blob, optionally\nwith ",Object(r.b)("inlineCode",{parentName:"p"},"options")," for customizing the output."),Object(r.b)("p",{parentName:"li"},"For example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"  onReceive: function (events) {\n    console.log(Stalker.parse(events, {\n      annotate: true, // to display the type of event\n      stringify: true\n        // to format pointer values as strings instead of `NativePointer`\n        // values, i.e. less overhead if you're just going to `send()` the\n        // thing not actually parse the data agent-side\n    }));\n  },\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Stalker.flush()"),": flush out any buffered events. Useful when you don't want\nto wait until the next ",Object(r.b)("inlineCode",{parentName:"p"},"Stalker.queueDrainInterval")," tick.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Stalker.garbageCollect()"),": free accumulated memory at a safe point after\n",Object(r.b)("inlineCode",{parentName:"p"},"Stalker#unfollow"),". This is needed to avoid race-conditions where the\nthread just unfollowed is executing its last instructions.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Stalker.addCallProbe(address, callback[, data])"),": call ",Object(r.b)("inlineCode",{parentName:"p"},"callback")," (see\n",Object(r.b)("inlineCode",{parentName:"p"},"Interceptor#attach#onEnter")," for signature) synchronously when a call is\nmade to ",Object(r.b)("inlineCode",{parentName:"p"},"address"),". Returns an id that can be passed to\n",Object(r.b)("inlineCode",{parentName:"p"},"Stalker#removeCallProbe")," later."),Object(r.b)("p",{parentName:"li"},"It is also possible to implement ",Object(r.b)("inlineCode",{parentName:"p"},"callback")," in C using ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#cmodule"}),"CModule"),",\nby specifying a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," instead of a function. Signature:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"void onCall (GumCallSite * site, gpointer user_data)"))),Object(r.b)("p",{parentName:"li"},"In such cases, the third optional argument ",Object(r.b)("inlineCode",{parentName:"p"},"data")," may be a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer"),"\nwhose value is passed to the callback as ",Object(r.b)("inlineCode",{parentName:"p"},"user_data"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Stalker.removeCallProbe"),": remove a call probe added by\n",Object(r.b)("inlineCode",{parentName:"p"},"Stalker#addCallProbe"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Stalker.trustThreshold"),": an integer specifying how many times a piece of\ncode needs to be executed before it is assumed it can be trusted to not\nmutate.\nSpecify -1 for no trust (slow), 0 to trust code from the get-go, and N to\ntrust code after it has been executed N times. Defaults to 1.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Stalker.queueCapacity"),": an integer specifying the capacity of the event\nqueue in number of events. Defaults to 16384 events.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Stalker.queueDrainInterval"),": an integer specifying the time in milliseconds\nbetween each time the event queue is drained. Defaults to 250 ms, which\nmeans that the event queue is drained four times per second. You may also\nset this property to zero to disable periodic draining, and instead call\n",Object(r.b)("inlineCode",{parentName:"p"},"Stalker.flush()")," when you would like the queue to be drained."))),Object(r.b)("h2",{id:"apiresolver"},"ApiResolver"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"new ApiResolver(type)"),": create a new resolver of the given ",Object(r.b)("inlineCode",{parentName:"p"},"type"),", allowing\nyou to quickly find functions by name, with globs permitted. Precisely which\nresolvers are available depends on the current platform and runtimes loaded\nin the current process. As of the time of writing, the available resolvers\nare:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"module"),": Resolves exported and imported functions of shared libraries\ncurrently loaded. Always available."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"objc"),": Resolves Objective-C methods of classes currently loaded.\nAvailable on macOS and iOS in processes that have the Objective-C\nruntime loaded. Use ",Object(r.b)("inlineCode",{parentName:"li"},"ObjC.available")," to check at runtime, or\nwrap your ",Object(r.b)("inlineCode",{parentName:"li"},"new ApiResolver('objc')")," call in a ",Object(r.b)("em",{parentName:"li"},"try-catch"),".")),Object(r.b)("p",{parentName:"li"},"The resolver will load the minimum amount of data required on creation, and\nlazy-load the rest depending on the queries it receives. It is thus\nrecommended to use the same instance for a batch of queries, but recreate it\nfor future batches to avoid looking at stale data."))),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"enumerateMatches(query)"),": performs the resolver-specific ",Object(r.b)("inlineCode",{parentName:"p"},"query")," string,\nreturning an array of objects containing the following properties:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"name"),": name of the API that was found"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"address"),": address as a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer"))))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var resolver = new ApiResolver('module');\nvar matches = resolver.enumerateMatches('exports:*!open*');\nvar first = matches[0];\n/*\n * Where `first` is an object similar to:\n *\n * {\n *   name: '/usr/lib/libSystem.B.dylib!opendir$INODE64',\n *   address: ptr('0x7fff870135c9')\n * }\n */\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var resolver = new ApiResolver('objc');\nvar matches = resolver.enumerateMatches('-[NSURL* *HTTP*]');\nvar first = matches[0];\n/*\n * Where `first` contains an object like this one:\n *\n * {\n *   name: '-[NSURLRequest valueForHTTPHeaderField:]',\n *   address: ptr('0x7fff94183e22')\n * }\n */\n")),Object(r.b)("h2",{id:"debugsymbol"},"DebugSymbol"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"DebugSymbol.fromAddress(address)"),", ",Object(r.b)("inlineCode",{parentName:"p"},"DebugSymbol.fromName(name)"),":\nlook up debug information for ",Object(r.b)("inlineCode",{parentName:"p"},"address"),"/",Object(r.b)("inlineCode",{parentName:"p"},"name")," and return it as an object\ncontaining:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"address"),": Address that this symbol is for, as a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"name"),": Name of the symbol, as a string, or null if unknown."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"moduleName"),": Module name owning this symbol, as a string, or null if\nunknown."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"fileName"),": File name owning this symbol, as a string, or null if\nunknown."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"lineNumber"),": Line number in ",Object(r.b)("inlineCode",{parentName:"li"},"fileName"),", as a number, or null if\nunknown.")),Object(r.b)("p",{parentName:"li"},"You may also call ",Object(r.b)("inlineCode",{parentName:"p"},"toString()")," on it, which is very useful when combined\nwith ",Object(r.b)("inlineCode",{parentName:"p"},"Thread.backtrace()"),":"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var f = Module.getExportByName('libcommonCrypto.dylib',\n    'CCCryptorCreate');\nInterceptor.attach(f, {\n  onEnter: function (args) {\n    console.log('CCCryptorCreate called from:\\n' +\n        Thread.backtrace(this.context, Backtracer.ACCURATE)\n        .map(DebugSymbol.fromAddress).join('\\n') + '\\n');\n  }\n});\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"DebugSymbol.getFunctionByName(name)"),": resolves a function name and\nreturns its address as a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer"),". Returns the first if more than\none function is found. Throws an exception if the name cannot be resolved.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"DebugSymbol.findFunctionsNamed(name)"),": resolves a function name and returns\nits addresses as an array of ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," objects.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"DebugSymbol.findFunctionsMatching(glob)"),": resolves function names matching\n",Object(r.b)("inlineCode",{parentName:"p"},"glob")," and returns their addresses as an array of ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer")," objects."))),Object(r.b)("h2",{id:"cmodule"},"CModule"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"new CModule(source[, symbols])"),": compiles C ",Object(r.b)("inlineCode",{parentName:"p"},"source")," code string to machine\ncode, straight to memory."),Object(r.b)("p",{parentName:"li"},"Useful for implementing hot callbacks, e.g. for ",Object(r.b)("em",{parentName:"p"},"Interceptor")," and ",Object(r.b)("em",{parentName:"p"},"Stalker"),",\nbut also useful when needing to start new threads in order to call functions\nin a tight loop, e.g. for fuzzing purposes."),Object(r.b)("p",{parentName:"li"},"Global functions are automatically exported as ",Object(r.b)("em",{parentName:"p"},"NativePointer")," properties\nnamed exactly like in the C source code. This means you can pass them to\n",Object(r.b)("em",{parentName:"p"},"Interceptor")," and ",Object(r.b)("em",{parentName:"p"},"Stalker"),", or call them using ",Object(r.b)("em",{parentName:"p"},"NativeFunction"),"."),Object(r.b)("p",{parentName:"li"},"The optional second argument, ",Object(r.b)("inlineCode",{parentName:"p"},"symbols"),", is an object specifying additional\nsymbol names and their ",Object(r.b)("em",{parentName:"p"},"NativePointer")," values, each of which will be plugged\nin at creation. This may for example be one or more memory blocks allocated\nusing ",Object(r.b)("em",{parentName:"p"},"Memory.alloc()"),", and/or ",Object(r.b)("em",{parentName:"p"},"NativeCallback")," values for receiving\ncallbacks from the C module."),Object(r.b)("p",{parentName:"li"},"To perform initialization and cleanup, you may define functions with the\nfollowing names and signatures:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"void init (void)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"void finalize (void)"))),Object(r.b)("p",{parentName:"li"},"Note that all data is read-only, so writable globals should be declared\n",Object(r.b)("em",{parentName:"p"},"extern"),", allocated using e.g. ",Object(r.b)("em",{parentName:"p"},"Memory.alloc()"),", and passed in as symbols\nthrough the constructor's second argument."))),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"dispose()"),": eagerly unmaps the module from memory. Useful for short-lived\nmodules when waiting for a future garbage collection isn't desirable.")),Object(r.b)("h3",{id:"examples"},"Examples"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var source = [\n  '#include <stdio.h>',\n  '',\n  'void hello(void) {',\n  '  printf(\"Hello World from CModule\\\\n\");',\n  '}',\n].join('\\n');\n\nvar cm = new CModule(source);\n\nconsole.log(JSON.stringify(cm));\n\nvar hello = new NativeFunction(cm.hello, 'void', []);\nhello();\n")),Object(r.b)("p",null,"Which you might load using Frida's REPL:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell",metastring:"script",script:!0}),"$ frida -p 0 -l example.js\n")),Object(r.b)("p",null,"(The REPL monitors the file on disk and reloads the script on change.)"),Object(r.b)("p",null,"You can then type ",Object(r.b)("inlineCode",{parentName:"p"},"hello()")," in the REPL to call the C function."),Object(r.b)("p",null,"The same example can be simplified by using modern JavaScript syntax:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const source = `\n#include <stdio.h>\n\nvoid hello(void) {\n  printf(\"Hello World from CModule\\\\n\");\n}\n`;\n\nconst cm = new CModule(source);\n\nconst hello = new NativeFunction(cm.hello, 'void', []);\nhello();\n")),Object(r.b)("p",null,"Which our V8-based runtime supports:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell",metastring:"script",script:!0}),"$ frida -p 0 --runtime=v8 -l example.js\n")),Object(r.b)("p",null,"Another option is to use ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/oleavr/frida-agent-example"}),"frida-compile"),"\nto compile the JavaScript code to ES5, so it can be run on our Duktape-based\nruntime."),Object(r.b)("p",null,"For prototyping we recommend using Frida's REPL:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell",metastring:"script",script:!0}),"$ frida -p 0 -C example.c\n")),Object(r.b)("p",null,"You may also add ",Object(r.b)("inlineCode",{parentName:"p"},"-l example.js")," to load some JavaScript next to it.\nThe JavaScript code may use the global variable named ",Object(r.b)("inlineCode",{parentName:"p"},"cm")," to access\nthe CModule object, but only after ",Object(r.b)("inlineCode",{parentName:"p"},"rpc.exports.init()")," has been called,\nso do any initialization depending on the CModule there. You may also\ninject symbols by assigning to the global object named ",Object(r.b)("inlineCode",{parentName:"p"},"cs"),", but this\nmust be done ",Object(r.b)("em",{parentName:"p"},"before")," ",Object(r.b)("inlineCode",{parentName:"p"},"rpc.exports.init()")," gets called."),Object(r.b)("p",null,"Here's an example:"),Object(r.b)("p",null,Object(r.b)("img",Object(a.a)({parentName:"p"},{src:"https://pbs.twimg.com/media/EEyxQzwXoAAqoAw?format=jpg&name=small",alt:"CModule REPL example"}))),Object(r.b)("p",null,"More details on CModule can be found in the ","[Frida 12.7 release notes]","({{\nsite.baseurl_root }}/news/2019/09/18/frida-12-7-released/)."),Object(r.b)("h2",{id:"instruction"},"Instruction"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Instruction.parse(target)"),": parse the instruction at the ",Object(r.b)("inlineCode",{parentName:"p"},"target")," address\nin memory, represented by a ",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer"),".\nNote that on 32-bit ARM this address must have its least significant bit\nset to 0 for ARM functions, and 1 for Thumb functions. Frida takes care\nof this detail for you if you get the address from a Frida API (for\nexample ",Object(r.b)("inlineCode",{parentName:"p"},"Module.getExportByName()"),")."),Object(r.b)("p",{parentName:"li"},"The object returned has the fields:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"address"),": address (EIP) of this instruction, as a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"next"),": pointer to the next instruction, so you can ",Object(r.b)("inlineCode",{parentName:"li"},"parse()")," it"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"size"),": size of this instruction"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"mnemonic"),": string representation of instruction mnemonic"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"opStr"),": string representation of instruction operands"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"operands"),": array of objects describing each operand, each specifying\nthe ",Object(r.b)("inlineCode",{parentName:"li"},"type")," and ",Object(r.b)("inlineCode",{parentName:"li"},"value"),", at a minimum, but potentially also\nadditional properties depending on the architecture"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"regsRead"),": array of register names implicitly read by this instruction"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"regsWritten"),": array of register names implicitly written to by this\ninstruction"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"groups"),": array of group names that this instruction belongs to"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"toString()"),": convert to a human-readable string")),Object(r.b)("p",{parentName:"li"},"For details about ",Object(r.b)("inlineCode",{parentName:"p"},"operands")," and ",Object(r.b)("inlineCode",{parentName:"p"},"groups"),", please consult the\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.capstone-engine.org/"}),"Capstone")," documentation for your\narchitecture."))),Object(r.b)("h2",{id:"kernel"},"Kernel"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Kernel.available"),": a boolean specifying whether the Kernel API is\navailable. Do not invoke any other ",Object(r.b)("inlineCode",{parentName:"p"},"Kernel")," properties or methods unless\nthis is the case.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Kernel.base"),": base address of the kernel, as a UInt64.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Kernel.pageSize"),": size of a kernel page in bytes, as a number.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Kernel.enumerateModules()"),": enumerates kernel modules loaded right now,\nreturning an array of objects containing the following properties:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"name"),": canonical module name as a string"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"base"),": base address as a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"size"),": size in bytes"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Kernel.enumerateRanges(protection|specifier)"),": enumerate kernel memory\nranges satisfying ",Object(r.b)("inlineCode",{parentName:"p"},"protection")," given as a string of the form: ",Object(r.b)("inlineCode",{parentName:"p"},"rwx"),", where\n",Object(r.b)("inlineCode",{parentName:"p"},"rw-"),' means "must be at least readable and writable". Alternatively you may\nprovide a ',Object(r.b)("inlineCode",{parentName:"p"},"specifier")," object with a ",Object(r.b)("inlineCode",{parentName:"p"},"protection")," key whose value is as\naforementioned, and a ",Object(r.b)("inlineCode",{parentName:"p"},"coalesce")," key set to ",Object(r.b)("inlineCode",{parentName:"p"},"true")," if you'd like neighboring\nranges with the same protection to be coalesced (the default is ",Object(r.b)("inlineCode",{parentName:"p"},"false"),";\ni.e. keeping the ranges separate). Returns an array of objects containing\nthe following properties:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"base"),": base address as a ",Object(r.b)("inlineCode",{parentName:"li"},"NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"size"),": size in bytes"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"protection"),": protection string (see above)"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Kernel.enumerateModuleRanges(name, protection)"),": just like\n",Object(r.b)("inlineCode",{parentName:"p"},"Kernel.enumerateRanges"),", except it's scoped to the specified module\n",Object(r.b)("inlineCode",{parentName:"p"},"name")," \u2013 which may be ",Object(r.b)("inlineCode",{parentName:"p"},"null")," for the module of the kernel itself. Each\nrange also has a ",Object(r.b)("inlineCode",{parentName:"p"},"name")," field containing a unique identifier as a string.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Kernel.alloc(size)"),": allocate ",Object(r.b)("inlineCode",{parentName:"p"},"size")," bytes of kernel memory, rounded up to\na multiple of the kernel's page size. The returned value is a ",Object(r.b)("inlineCode",{parentName:"p"},"UInt64"),"\nspecifying the base address of the allocation.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Kernel.protect(address, size, protection)"),": update protection on a region\nof kernel memory, where ",Object(r.b)("inlineCode",{parentName:"p"},"protection")," is a string of the same format as\n",Object(r.b)("inlineCode",{parentName:"p"},"Kernel.enumerateRanges()"),"."),Object(r.b)("p",{parentName:"li"},"For example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"Kernel.protect(UInt64('0x1234'), 4096, 'rw-');\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Kernel.readByteArray(address, length)"),": just like\n",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer#readByteArray"),", but reading from kernel memory.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Kernel.writeByteArray(address, bytes)"),": just like\n",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer#writeByteArray"),", but writing to kernel memory.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Kernel.scan(address, size, pattern, callbacks)"),": just like ",Object(r.b)("inlineCode",{parentName:"p"},"Memory.scan"),",\nbut scanning kernel memory."))),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Kernel.scanSync(address, size, pattern)"),": synchronous version of ",Object(r.b)("inlineCode",{parentName:"li"},"scan()"),"\nthat returns the matches in an array.")),Object(r.b)("h2",{id:"objc"},"ObjC"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.available"),": a boolean specifying whether the current process has an\nObjective-C runtime loaded. Do not invoke any other ",Object(r.b)("inlineCode",{parentName:"p"},"ObjC")," properties or\nmethods unless this is the case.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.api"),": an object mapping function names to ",Object(r.b)("inlineCode",{parentName:"p"},"NativeFunction")," instances\nfor direct access to a big portion of the Objective-C runtime API.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.classes"),": an object mapping class names to ",Object(r.b)("inlineCode",{parentName:"p"},"ObjC.Object")," JavaScript\nbindings for each of the currently registered classes. You can interact with\nobjects by using dot notation and replacing colons with underscores, i.e.:\n",Object(r.b)("inlineCode",{parentName:"p"},'[NSString stringWithString:@"Hello World"]'),"\nbecomes\n",Object(r.b)("inlineCode",{parentName:"p"},'var NSString = ObjC.classes.NSString; NSString.stringWithString_("Hello World");'),".\nNote the underscore after the method name. Refer to iOS Examples section for\nmore details.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.protocols"),": an object mapping protocol names to ",Object(r.b)("inlineCode",{parentName:"p"},"ObjC.Protocol"),"\nJavaScript bindings for each of the currently registered protocols.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.mainQueue"),": the GCD queue of the main thread")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.schedule(queue, work)"),": schedule the JavaScript function ",Object(r.b)("inlineCode",{parentName:"p"},"work")," on\nthe GCD queue specified by ",Object(r.b)("inlineCode",{parentName:"p"},"queue"),". An ",Object(r.b)("inlineCode",{parentName:"p"},"NSAutoreleasePool")," is created just\nbefore calling ",Object(r.b)("inlineCode",{parentName:"p"},"work"),", and cleaned up on return."))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'var NSSound = ObjC.classes.NSSound; /* macOS */\nObjC.schedule(ObjC.mainQueue, function () {\n    var sound = NSSound.alloc().initWithContentsOfFile_byReference_("/Users/oleavr/.Trash/test.mp3", true);\n    sound.play();\n});\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new ObjC.Object(handle[, protocol])"),": create a JavaScript binding given\nthe existing object at ",Object(r.b)("inlineCode",{parentName:"li"},"handle")," (a NativePointer). You may also specify\nthe ",Object(r.b)("inlineCode",{parentName:"li"},"protocol")," argument if you'd like to treat ",Object(r.b)("inlineCode",{parentName:"li"},"handle")," as an object\nimplementing a certain protocol only.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'Interceptor.attach(myFunction.implementation, {\n  onEnter: function(args) {\n    // ObjC: args[0] = self, args[1] = selector, args[2-n] = arguments\n    var myString = new ObjC.Object(args[2]);\n    console.log("String argument: " + myString.toString());\n  }\n});\n')),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"  This object has some special properties:"),Object(r.b)("ul",{parentName:"blockquote"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"$kind"),": string specifying either ",Object(r.b)("inlineCode",{parentName:"p"},"instance"),", ",Object(r.b)("inlineCode",{parentName:"p"},"class")," or ",Object(r.b)("inlineCode",{parentName:"p"},"meta-class"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"$super"),": an ",Object(r.b)("em",{parentName:"p"},"ObjC.Object")," instance used for chaining up to super-class\nmethod implementations")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"$superClass"),": super-class as an ",Object(r.b)("em",{parentName:"p"},"ObjC.Object")," instance")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"$class"),": class of this object as an ",Object(r.b)("em",{parentName:"p"},"ObjC.Object")," instance")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"$className"),": string containing the class name of this object")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"$moduleName"),": string containing the module path of this object")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"$protocols"),": object mapping protocol name to ",Object(r.b)("inlineCode",{parentName:"p"},"ObjC.Protocol")," instance\nfor each of the protocols that this object conforms to")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"$methods"),": array containing native method names exposed by this object's\nclass and parent classes")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"$ownMethods"),": array containing native method names exposed by this object's\nclass, not including parent classes")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"$ivars"),": object mapping each instance variable name to its current\nvalue, allowing you to read and write each through access and assignment"),Object(r.b)("p",{parentName:"li"},"There is also an ",Object(r.b)("inlineCode",{parentName:"p"},"equals(other)")," method for checking whether two instances\nrefer to the same underlying object."),Object(r.b)("p",{parentName:"li"},"Note that all method wrappers provide a ",Object(r.b)("inlineCode",{parentName:"p"},"clone(options)")," API to create a new\nmethod wrapper with custom ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#nativefunction"}),"NativeFunction")," options.")))),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"new ObjC.Protocol(handle)"),": create a JavaScript binding given the existing\nprotocol at ",Object(r.b)("inlineCode",{parentName:"p"},"handle")," (a NativePointer).")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"new ObjC.Block(target[, options])"),": create a JavaScript binding given the\nexisting block at ",Object(r.b)("inlineCode",{parentName:"p"},"target")," (a NativePointer), or, to define a new block,\n",Object(r.b)("inlineCode",{parentName:"p"},"target")," should be an object specifying the type signature and JavaScript\nfunction to call whenever the block is invoked. The function is specified\nwith an ",Object(r.b)("inlineCode",{parentName:"p"},"implementation")," key, and the signature is specified either through\na ",Object(r.b)("inlineCode",{parentName:"p"},"types")," key, or through the ",Object(r.b)("inlineCode",{parentName:"p"},"retType")," and ",Object(r.b)("inlineCode",{parentName:"p"},"argTypes")," keys. See\n",Object(r.b)("inlineCode",{parentName:"p"},"ObjC.registerClass()")," for details."),Object(r.b)("p",{parentName:"li"},"You may also provide an ",Object(r.b)("inlineCode",{parentName:"p"},"options")," object with the same options as supported\nby ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#nativefunction"}),"NativeFunction"),", e.g. to pass ",Object(r.b)("inlineCode",{parentName:"p"},"traps: 'all'")," in order\nto ",Object(r.b)("inlineCode",{parentName:"p"},"Stalker.follow()")," the execution when calling the block."),Object(r.b)("p",{parentName:"li"},"The most common use-case is hooking an existing block, which for a block\nexpecting two arguments would look something like:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const pendingBlocks = new Set();\n\nInterceptor.attach(..., {\n  onEnter(args) {\n    const block = new ObjC.Block(args[4]);\n    pendingBlocks.add(block); // Keep it alive\n    const appCallback = block.implementation;\n    block.implementation = (error, value) => {\n      // Do your logging here\n      const result = appCallback(error, value);\n      pendingBlocks.delete(block);\n      return result;\n    };\n  }\n});\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ObjC.implement(method, fn)"),": create a JavaScript implementation compatible\nwith the signature of ",Object(r.b)("inlineCode",{parentName:"li"},"method"),", where the JavaScript function ",Object(r.b)("inlineCode",{parentName:"li"},"fn")," is used\nas the implementation. Returns a ",Object(r.b)("inlineCode",{parentName:"li"},"NativeCallback")," that you may assign to an\nObjC method's ",Object(r.b)("inlineCode",{parentName:"li"},"implementation")," property.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var NSSound = ObjC.classes.NSSound; /* macOS */\nvar oldImpl = NSSound.play.implementation;\nNSSound.play.implementation = ObjC.implement(NSSound.play, function (handle, selector) {\n  return oldImpl(handle, selector);\n});\n\nvar NSView = ObjC.classes.NSView; /* macOS */\nvar drawRect = NSView['- drawRect:'];\nvar oldImpl = drawRect.implementation;\ndrawRect.implementation = ObjC.implement(drawRect, function (handle, selector) {\n  oldImpl(handle, selector);\n});\n")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"  As the ",Object(r.b)("inlineCode",{parentName:"p"},"implementation")," property is a ",Object(r.b)("inlineCode",{parentName:"p"},"NativeFunction")," and thus also a\n",Object(r.b)("inlineCode",{parentName:"p"},"NativePointer"),", you may also use ",Object(r.b)("inlineCode",{parentName:"p"},"Interceptor")," to hook functions:")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'var NSSound = ObjC.classes.NSSound; /* macOS */\nInterceptor.attach(NSSound.play.implementation, {\n    onEnter: function () {\n        send("[NSSound play]");\n    }\n});\n')),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.registerProxy(properties)"),": create a new class designed to act as a\nproxy for a target object, where ",Object(r.b)("inlineCode",{parentName:"p"},"properties")," is an object specifying:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"protocols"),": (optional) Array of protocols this class conforms to."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"methods"),": (optional) Object specifying methods to implement."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"events"),": (optional) Object specifying callbacks for getting notified\nabout events:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"dealloc: function ()"),": Called right after the object has been\ndeallocated. This is where you might clean up any associated state."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"forward: function (name)"),": Called with ",Object(r.b)("inlineCode",{parentName:"li"},"name")," specifying the\nmethod name that we're about to forward a call to. This might be\nwhere you'd start out with a temporary callback that just logs the\nnames to help you decide which methods to override.")))))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const MyConnectionDelegateProxy = ObjC.registerProxy({\n  protocols: [ObjC.protocols.NSURLConnectionDataDelegate],\n  methods: {\n    '- connection:didReceiveResponse:': function (conn, resp) {\n      /* fancy logging code here */\n      /* this.data.foo === 1234 */\n      this.data.target\n          .connection_didReceiveResponse_(conn, resp);\n    },\n    '- connection:didReceiveData:': function (conn, data) {\n      /* other logging code here */\n      this.data.target\n          .connection_didReceiveData_(conn, data);\n    }\n  },\n  events: {\n    forward: function (name) {\n      console.log('*** forwarding: ' + name);\n    }\n  }\n});\n\nconst method = ObjC.classes.NSURLConnection[\n    '- initWithRequest:delegate:startImmediately:'];\nInterceptor.attach(method.implementation, {\n  onEnter: function (args) {\n    args[3] = new MyConnectionDelegateProxy(args[3], {\n      foo: 1234\n    });\n  }\n});\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.registerClass(properties)"),": create a new Objective-C class, where\n",Object(r.b)("inlineCode",{parentName:"p"},"properties")," is an object specifying:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"name"),": (optional) String specifying the name of the class; omit this\nif you don't care about the globally visible name and would like the\nruntime to auto-generate one for you."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"super"),": (optional) Super-class, or ",Object(r.b)("em",{parentName:"li"},"null")," to create a new root class;\nomit to inherit from ",Object(r.b)("em",{parentName:"li"},"NSObject"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"protocols"),": (optional) Array of protocols this class conforms to."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"methods"),": (optional) Object specifying methods to implement.")))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const MyConnectionDelegateProxy = ObjC.registerClass({\n  name: 'MyConnectionDelegateProxy',\n  super: ObjC.classes.NSObject,\n  protocols: [ObjC.protocols.NSURLConnectionDataDelegate],\n  methods: {\n    '- init': function () {\n      const self = this.super.init();\n      if (self !== null) {\n        ObjC.bind(self, {\n          foo: 1234\n        });\n      }\n      return self;\n    },\n    '- dealloc': function () {\n      ObjC.unbind(this.self);\n      this.super.dealloc();\n    },\n    '- connection:didReceiveResponse:': function (conn, resp) {\n      /* this.data.foo === 1234 */\n    },\n    /*\n     * But those previous methods are declared assuming that\n     * either the super-class or a protocol we conform to has\n     * the same method so we can grab its type information.\n     * However, if that's not the case, you would write it\n     * like this:\n     */\n    '- connection:didReceiveResponse:': {\n      retType: 'void',\n      argTypes: ['object', 'object'],\n      implementation: function (conn, resp) {\n      }\n    },\n    /* Or grab it from an existing class: */\n    '- connection:didReceiveResponse:': {\n      types: ObjC.classes\n          .Foo['- connection:didReceiveResponse:'].types,\n      implementation: function (conn, resp) {\n      }\n    },\n    /* Or from an existing protocol: */\n    '- connection:didReceiveResponse:': {\n      types: ObjC.protocols.NSURLConnectionDataDelegate\n          .methods['- connection:didReceiveResponse:'].types,\n      implementation: function (conn, resp) {\n      }\n    },\n    /* Or write the signature by hand if you really want to: */\n    '- connection:didReceiveResponse:': {\n      types: 'v32@0:8@16@24',\n      implementation: function (conn, resp) {\n      }\n    }\n  }\n});\n\nconst proxy = MyConnectionDelegateProxy.alloc().init();\n/* use `proxy`, and later: */\nproxy.release();\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.registerProtocol(properties)"),": create a new Objective-C protocol,\nwhere ",Object(r.b)("inlineCode",{parentName:"p"},"properties")," is an object specifying:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"name"),": (optional) String specifying the name of the protocol; omit this\nif you don't care about the globally visible name and would like the\nruntime to auto-generate one for you."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"protocols"),": (optional) Array of protocols this protocol incorporates."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"methods"),": (optional) Object specifying methods to declare.")))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const MyDataDelegate = ObjC.registerProtocol({\n  name: 'MyDataDelegate',\n  protocols: [ObjC.protocols.NSURLConnectionDataDelegate],\n  methods: {\n    /* You must specify the signature: */\n    '- connection:didStuff:': {\n      retType: 'void',\n      argTypes: ['object', 'object']\n    },\n    /* Or grab it from a method of an existing class: */\n    '- connection:didStuff:': {\n      types: ObjC.classes\n          .Foo['- connection:didReceiveResponse:'].types\n    },\n    /* Or from an existing protocol method: */\n    '- connection:didStuff:': {\n      types: ObjC.protocols.NSURLConnectionDataDelegate\n          .methods['- connection:didReceiveResponse:'].types\n    },\n    /* Or write the signature by hand if you really want to: */\n    '- connection:didStuff:': {\n      types: 'v32@0:8@16@24'\n    },\n    /* You can also make a method optional (default is required): */\n    '- connection:didStuff:': {\n      retType: 'void',\n      argTypes: ['object', 'object'],\n      optional: true\n    }\n  }\n});\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.bind(obj, data)"),": bind some JavaScript data to an Objective-C\ninstance; see ",Object(r.b)("inlineCode",{parentName:"p"},"ObjC.registerClass()")," for an example.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.unbind(obj)"),": unbind previous associated JavaScript data from an\nObjective-C instance; see ",Object(r.b)("inlineCode",{parentName:"p"},"ObjC.registerClass()")," for an example.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.getBoundData(obj)"),": look up previously bound data from an Objective-C\nobject.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.enumerateLoadedClasses([options, ]callbacks)"),": enumerate classes\nloaded right now, where ",Object(r.b)("inlineCode",{parentName:"p"},"callbacks")," is an object specifying:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onMatch: function (name, owner)"),": called for each loaded class with the\n",Object(r.b)("inlineCode",{parentName:"p"},"name")," of the class as a string, and ",Object(r.b)("inlineCode",{parentName:"p"},"owner")," specifying the path to the\nmodule where the class was loaded from. To obtain a JavaScript wrapper\nfor a given class, do: ",Object(r.b)("inlineCode",{parentName:"p"},"ObjC.classes[name]"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onComplete: function ()"),": called when all classes have been enumerated."))),Object(r.b)("p",{parentName:"li"},"For example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"ObjC.enumerateLoadedClasses({\n  onMatch: function (name, owner) {\n    console.log('onMatch:', name, owner);\n  },\n  onComplete: function () {\n  }\n});\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"The optional `options` argument is an object where you may specify the\n`ownedBy` property to limit enumeration to modules in a given `ModuleMap`.\n\nFor example:\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var appModules = new ModuleMap(isAppModule);\nObjC.enumerateLoadedClasses({ ownedBy: appModules }, {\n  onMatch: function (name, owner) {\n    console.log('onMatch:', name, owner);\n  },\n  onComplete: function () {\n  }\n});\n\nfunction isAppModule(m) {\n  return !/^\\/(usr\\/lib|System|Developer)\\//.test(m.path);\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.enumerateLoadedClassesSync([options])"),": synchronous version of\n",Object(r.b)("inlineCode",{parentName:"p"},"enumerateLoadedClasses()")," that returns an object mapping owner module to\nan array of class names."),Object(r.b)("p",{parentName:"li"},"For example:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var appModules = new ModuleMap(isAppModule);\nvar appClasses = ObjC.enumerateLoadedClassesSync({ ownedBy: appModules });\nconsole.log('appClasses:', JSON.stringify(appClasses));\n\nfunction isAppModule(m) {\n  return !/^\\/(usr\\/lib|System|Developer)\\//.test(m.path);\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.choose(specifier, callbacks)"),": enumerate live instances of classes\nmatching ",Object(r.b)("inlineCode",{parentName:"p"},"specifier")," by scanning the heap. ",Object(r.b)("inlineCode",{parentName:"p"},"specifier")," is either a class\nselector or an object specifying a class selector and desired options.\nThe class selector is an ",Object(r.b)("em",{parentName:"p"},"ObjC.Object")," of a class, e.g.\n",Object(r.b)("em",{parentName:"p"},"ObjC.classes.UIButton"),".\nWhen passing an object as the specifier you should provide the ",Object(r.b)("inlineCode",{parentName:"p"},"class"),"\nfield with your class selector, and the ",Object(r.b)("inlineCode",{parentName:"p"},"subclasses")," field with a\nboolean indicating whether you're also interested in subclasses matching the\ngiven class selector. The default is to also include subclasses.\nThe ",Object(r.b)("inlineCode",{parentName:"p"},"callbacks")," argument is an object specifying:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onMatch: function (instance)"),": called once for each live instance found\nwith a ready-to-use ",Object(r.b)("inlineCode",{parentName:"p"},"instance")," just as if you would have called\n",Object(r.b)("inlineCode",{parentName:"p"},'new ObjC.Object(ptr("0x1234"))')," knowing that this particular\nObjective-C instance lives at ",Object(r.b)("em",{parentName:"p"},"0x1234"),"."),Object(r.b)("p",{parentName:"li"},"This function may return the string ",Object(r.b)("inlineCode",{parentName:"p"},"stop")," to cancel the enumeration\nearly.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onComplete: function ()"),": called when all instances have been enumerated")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.chooseSync(specifier)"),": synchronous version of ",Object(r.b)("inlineCode",{parentName:"p"},"choose()")," that returns\nthe instances in an array.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.selector(name)"),": convert the JavaScript string ",Object(r.b)("inlineCode",{parentName:"p"},"name")," to a selector")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ObjC.selectorAsString(sel)"),": convert the selector ",Object(r.b)("inlineCode",{parentName:"p"},"sel")," to a JavaScript\nstring"))),Object(r.b)("h2",{id:"java"},"Java"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.available"),": a boolean specifying whether the current process has the\na Java VM loaded, i.e. Dalvik or ART. Do not invoke any other ",Object(r.b)("inlineCode",{parentName:"p"},"Java"),"\nproperties or methods unless this is the case.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.androidVersion"),": a string specifying which version of Android we're\nrunning on.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.enumerateLoadedClasses(callbacks)"),": enumerate classes loaded right\nnow, where ",Object(r.b)("inlineCode",{parentName:"p"},"callbacks")," is an object specifying:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onMatch: function (name, handle)"),": called for each loaded class with\n",Object(r.b)("inlineCode",{parentName:"p"},"name")," that may be passed to ",Object(r.b)("inlineCode",{parentName:"p"},"use()")," to get a JavaScript wrapper.\nYou may also ",Object(r.b)("inlineCode",{parentName:"p"},"Java.cast()")," the ",Object(r.b)("inlineCode",{parentName:"p"},"handle")," to ",Object(r.b)("inlineCode",{parentName:"p"},"java.lang.Class"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onComplete: function ()"),": called when all classes have been enumerated.")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.enumerateLoadedClassesSync()"),": synchronous version of\n",Object(r.b)("inlineCode",{parentName:"p"},"enumerateLoadedClasses()")," that returns the class names in an array.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.enumerateClassLoaders(callbacks)"),": enumerate class loaders present\nin the Java VM, where ",Object(r.b)("inlineCode",{parentName:"p"},"callbacks")," is an object specifying:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onMatch: function (loader)"),": called for each class loader with\n",Object(r.b)("inlineCode",{parentName:"p"},"loader"),", a wrapper for the specific ",Object(r.b)("inlineCode",{parentName:"p"},"java.lang.ClassLoader"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onComplete: function ()"),": called when all class loaders have been\nenumerated."))),Object(r.b)("p",{parentName:"li"},"You may pass such a loader to ",Object(r.b)("inlineCode",{parentName:"p"},"Java.ClassFactory.get()")," to be able to\n",Object(r.b)("inlineCode",{parentName:"p"},".use()")," classes on the specified class loader.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.enumerateClassLoadersSync()"),": synchronous version of\n",Object(r.b)("inlineCode",{parentName:"p"},"enumerateClassLoaders()")," that returns the class loaders in an array.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.scheduleOnMainThread(fn)"),": run ",Object(r.b)("inlineCode",{parentName:"p"},"fn")," on the main thread of the VM.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.perform(fn)"),": ensure that the current thread is attached to the VM\nand call ",Object(r.b)("inlineCode",{parentName:"p"},"fn"),". (This isn't necessary in callbacks from Java.)\nWill defer calling ",Object(r.b)("inlineCode",{parentName:"p"},"fn")," if the app's class loader is not available yet.\nUse ",Object(r.b)("inlineCode",{parentName:"p"},"Java.performNow()")," if access to the app's classes is not needed."))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"Java.perform(function () {\n  var Activity = Java.use('android.app.Activity');\n  Activity.onResume.implementation = function () {\n    send('onResume() got called! Let\\'s call the original implementation');\n    this.onResume();\n  };\n});\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.performNow(fn)"),": ensure that the current thread is attached to the\nVM and call ",Object(r.b)("inlineCode",{parentName:"p"},"fn"),". (This isn't necessary in callbacks from Java.)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.use(className)"),": dynamically get a JavaScript wrapper for\n",Object(r.b)("inlineCode",{parentName:"p"},"className")," that you can instantiate objects from by calling ",Object(r.b)("inlineCode",{parentName:"p"},"$new()")," on\nit to invoke a constructor. Call ",Object(r.b)("inlineCode",{parentName:"p"},"$dispose()")," on an instance to clean it\nup explicitly (or wait for the JavaScript object to get garbage-collected,\nor script to get unloaded). Static and non-static methods are available,\nand you can even replace a method implementation and throw an exception\nfrom it:"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"Java.perform(function () {\n  var Activity = Java.use('android.app.Activity');\n  var Exception = Java.use('java.lang.Exception');\n  Activity.onResume.implementation = function () {\n    throw Exception.$new('Oh noes!');\n  };\n});\n")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"  Uses the app's class loader by default, but you may customize this by\nassigning a different loader instance to ",Object(r.b)("inlineCode",{parentName:"p"},"Java.classFactory.loader"),"."),Object(r.b)("p",{parentName:"blockquote"},"  Note that all method wrappers provide a ",Object(r.b)("inlineCode",{parentName:"p"},"clone(options)")," API to create a new\nmethod wrapper with custom ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#nativefunction"}),"NativeFunction")," options.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.openClassFile(filePath)"),": open the .dex file at ",Object(r.b)("inlineCode",{parentName:"p"},"filePath"),", returning\nan object with the following methods:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"load()"),": load the contained classes into the VM.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"getClassNames()"),": obtain an array of available class names.")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.choose(className, callbacks)"),": enumerate live instances of the\n",Object(r.b)("inlineCode",{parentName:"p"},"className")," class by scanning the Java heap, where ",Object(r.b)("inlineCode",{parentName:"p"},"callbacks")," is an\nobject specifying:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onMatch: function (instance)"),": called with each live instance found\nwith a ready-to-use ",Object(r.b)("inlineCode",{parentName:"p"},"instance")," just as if you would have called\n",Object(r.b)("inlineCode",{parentName:"p"},"Java.cast()")," with a raw handle to this particular instance."),Object(r.b)("p",{parentName:"li"},"This function may return the string ",Object(r.b)("inlineCode",{parentName:"p"},"stop")," to cancel the enumeration\nearly.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"onComplete: function ()"),": called when all instances have been enumerated")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.retain(obj)"),": duplicates the JavaScript wrapper ",Object(r.b)("inlineCode",{parentName:"p"},"obj")," for later use\noutside replacement method."))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"Java.perform(function () {\n  var Activity = Java.use('android.app.Activity');\n  var lastActivity = null;\n  Activity.onResume.implementation = function () {\n    lastActivity = Java.retain(this);\n    this.onResume();\n  };\n});\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Java.cast(handle, klass)"),": create a JavaScript wrapper given the existing\ninstance at ",Object(r.b)("inlineCode",{parentName:"li"},"handle")," of given class ",Object(r.b)("inlineCode",{parentName:"li"},"klass")," as returned from ",Object(r.b)("inlineCode",{parentName:"li"},"Java.use()"),".\nSuch a wrapper also has a ",Object(r.b)("inlineCode",{parentName:"li"},"class")," property for getting a wrapper for its\nclass, and a ",Object(r.b)("inlineCode",{parentName:"li"},"$className")," property for getting a string representation of\nits class-name.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var Activity = Java.use('android.app.Activity');\nvar activity = Java.cast(ptr('0x1234'), Activity);\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Java.array(type, elements)"),": creates a Java array with elements of the\nspecified ",Object(r.b)("inlineCode",{parentName:"li"},"type"),", from a JavaScript array ",Object(r.b)("inlineCode",{parentName:"li"},"elements"),". The resulting Java\narray behaves like a JS array, but can be passed by reference to Java APIs\nin order to allow them to modify its contents.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var values = Java.array('int', [ 1003, 1005, 1007 ]);\n\nvar JString = Java.use('java.lang.String');\nvar str = JString.$new(Java.array('byte', [ 0x48, 0x65, 0x69 ]));\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.isMainThread()"),": determine whether the caller is running on the main\nthread.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.registerClass(spec)"),": create a new Java class and return a wrapper for\nit, where ",Object(r.b)("inlineCode",{parentName:"p"},"spec")," is an object containing:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"name"),": String specifying the name of the class."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"superClass"),": (optional) Super-class. Omit to inherit from\n",Object(r.b)("inlineCode",{parentName:"li"},"java.lang.Object"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"implements"),": (optional) Array of interfaces implemented by this class."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"fields"),": (optional) Object specifying the name and type of each field\nto expose."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"methods"),": (optional) Object specifying methods to implement.")))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var SomeBaseClass = Java.use('com.example.SomeBaseClass');\nvar X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');\n\nvar MyTrustManager = Java.registerClass({\n  name: 'com.example.MyTrustManager',\n  implements: [X509TrustManager],\n  methods: {\n    checkClientTrusted: function (chain, authType) {\n    },\n    checkServerTrusted: function (chain, authType) {\n    },\n    getAcceptedIssuers: function () {\n      return [];\n    },\n  }\n});\n\nvar MyWeirdTrustManager = Java.registerClass({\n  name: 'com.example.MyWeirdTrustManager',\n  superClass: SomeBaseClass,\n  implements: [X509TrustManager],\n  fields: {\n    description: 'java.lang.String',\n    limit: 'int',\n  },\n  methods: {\n    $init: function () {\n      console.log('Constructor called');\n    },\n    checkClientTrusted: function (chain, authType) {\n      console.log('checkClientTrusted');\n    },\n    checkServerTrusted: [{\n      returnType: 'void',\n      argumentTypes: ['[Ljava.security.cert.X509Certificate;', 'java.lang.String'],\n      implementation: function (chain, authType) {\n        console.log('checkServerTrusted A');\n      }\n    }, {\n      returnType: 'java.util.List',\n      argumentTypes: ['[Ljava.security.cert.X509Certificate;', 'java.lang.String', 'java.lang.String'],\n      implementation: function (chain, authType, host) {\n        console.log('checkServerTrusted B');\n        return null;\n      }\n    }],\n    getAcceptedIssuers: function () {\n      console.log('getAcceptedIssuers');\n      return [];\n    },\n  }\n});\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.deoptimizeEverything()"),": forces the VM to execute everything with\nits interpreter. Necessary to prevent optimizations from bypassing method\nhooks in some cases, and allows ART's Instrumentation APIs to be used for\ntracing the runtime.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.vm"),": object with the following methods:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"perform(fn)"),": ensures that the current thread is attached to the VM and\ncalls ",Object(r.b)("inlineCode",{parentName:"p"},"fn"),". (This isn't necessary in callbacks from Java.)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"getEnv()"),": gets a wrapper for the current thread's ",Object(r.b)("inlineCode",{parentName:"p"},"JNIEnv"),". Throws an\nexception if the current thread is not attached to the VM.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"tryGetEnv()"),": tries to get a wrapper for the current thread's ",Object(r.b)("inlineCode",{parentName:"p"},"JNIEnv"),".\nReturns ",Object(r.b)("inlineCode",{parentName:"p"},"null")," if the current thread is not attached to the VM.")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.classFactory"),": the default class factory used to implement e.g.\n",Object(r.b)("inlineCode",{parentName:"p"},"Java.use()"),". Uses the application's main class loader.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"Java.ClassFactory"),": class with the following properties:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"get(classLoader)"),": Gets the class factory instance for a given class\nloader. The default class factory used behind the scenes only interacts\nwith the application's main class loader. Other class loaders can be\ndiscovered through ",Object(r.b)("inlineCode",{parentName:"li"},"Java.enumerateClassLoaders()")," and interacted with\nthrough this API.")),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"loader"),": read-only property providing a wrapper for the class loader\ncurrently being used. For the default class factory this is updated by\nthe first call to ",Object(r.b)("inlineCode",{parentName:"p"},"Java.perform()"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"cacheDir"),": string containing path to cache directory currently being\nused. For the default class factory this is updated by the first call\nto ",Object(r.b)("inlineCode",{parentName:"p"},"Java.perform()"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"tempFileNaming"),": object specifying naming convention to use for\ntemporary files. Defaults to ",Object(r.b)("inlineCode",{parentName:"p"},"{ prefix: 'frida', suffix: 'dat' }"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"use(className)"),": like ",Object(r.b)("inlineCode",{parentName:"p"},"Java.use()")," but for a specific class loader.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"openClassFile(filePath)"),": like ",Object(r.b)("inlineCode",{parentName:"p"},"Java.openClassFile()")," but for a\nspecific class loader.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"choose(className, callbacks)"),": like ",Object(r.b)("inlineCode",{parentName:"p"},"Java.choose()")," but for a\nspecific class loader.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"retain(obj)"),": like ",Object(r.b)("inlineCode",{parentName:"p"},"Java.retain()")," but for a specific class loader.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"cast(handle, klass)"),": like ",Object(r.b)("inlineCode",{parentName:"p"},"Java.cast()")," but for a specific class\nloader.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"array(type, elements)"),": like ",Object(r.b)("inlineCode",{parentName:"p"},"Java.array()")," but for a specific class\nloader.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"registerClass(spec)"),": like ",Object(r.b)("inlineCode",{parentName:"p"},"Java.registerClass()")," but for a specific\nclass loader."))))),Object(r.b)("h2",{id:"weakref"},"WeakRef"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"WeakRef.bind(value, fn)"),": monitor ",Object(r.b)("inlineCode",{parentName:"p"},"value")," and call the ",Object(r.b)("inlineCode",{parentName:"p"},"fn")," callback as\nsoon as ",Object(r.b)("inlineCode",{parentName:"p"},"value")," has been garbage-collected, or the script is about to get\nunloaded. Returns an id that you can pass to ",Object(r.b)("inlineCode",{parentName:"p"},"WeakRef.unbind()")," for\nexplicit cleanup."),Object(r.b)("p",{parentName:"li"},"This API is useful if you're building a language-binding, where you need to\nfree native resources when a JS value is no longer needed.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"WeakRef.unbind(id)"),": stop monitoring the value passed to\n",Object(r.b)("inlineCode",{parentName:"p"},"WeakRef.bind(value, fn)"),", and call the ",Object(r.b)("inlineCode",{parentName:"p"},"fn")," callback immediately."))),Object(r.b)("h2",{id:"x86writer"},"X86Writer"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new X86Writer(codeAddress[, { pc: ptr('0x1234') }])"),": create a new code\nwriter for generating x86 machine code written directly to memory at\n",Object(r.b)("inlineCode",{parentName:"li"},"codeAddress"),", specified as a NativePointer.\nThe second argument is an optional options object where the initial program\ncounter may be specified, which is useful when generating code to a scratch\nbuffer. This is essential when using ",Object(r.b)("inlineCode",{parentName:"li"},"Memory.patchCode()")," on iOS, which may\nprovide you with a temporary location that later gets mapped into memory at\nthe intended memory location.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"reset(codeAddress[, { pc: ptr('0x1234') }])"),": recycle instance")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"dispose()"),": eagerly clean up memory")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"flush()"),": resolve label references and write pending data to memory. You\nshould always call this once you've finished generating code. It is usually\nalso desirable to do this between pieces of unrelated code, e.g. when\ngenerating multiple functions in one go.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"base"),": memory location of the first byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"code"),": memory location of the next byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"pc"),": program counter at the next byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"offset"),": current offset as a JavaScript Number")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLabel(id)"),": put a label at the current position, where ",Object(r.b)("inlineCode",{parentName:"p"},"id")," is a string\nthat may be referenced in past and future ",Object(r.b)("inlineCode",{parentName:"p"},"put*Label()")," calls")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallAddressWithArguments(func, args)"),": put code needed for calling a C\nfunction with the specified ",Object(r.b)("inlineCode",{parentName:"p"},"args"),", specified as a JavaScript array where\neach element is either a string specifying the register, or a Number or\nNativePointer specifying the immediate value.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallAddressWithAlignedArguments(func, args)"),": like above, but also\nensures that the argument list is aligned on a 16 byte boundary")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallRegWithArguments(reg, args)"),": put code needed for calling a C\nfunction with the specified ",Object(r.b)("inlineCode",{parentName:"p"},"args"),", specified as a JavaScript array where\neach element is either a string specifying the register, or a Number or\nNativePointer specifying the immediate value.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallRegWithAlignedArguments(reg, args)"),": like above, but also\nensures that the argument list is aligned on a 16 byte boundary")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallRegOffsetPtrWithArguments(reg, offset, args)"),": put code needed for calling a C\nfunction with the specified ",Object(r.b)("inlineCode",{parentName:"p"},"args"),", specified as a JavaScript array where\neach element is either a string specifying the register, or a Number or\nNativePointer specifying the immediate value.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallAddress(address)"),": put a CALL instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallReg(reg)"),": put a CALL instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallRegOffsetPtr(reg, offset)"),": put a CALL instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallIndirect(addr)"),": put a CALL instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallIndirectLabel(labelId)"),": put a CALL instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallNearLabel(labelId)"),": put a CALL instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLeave()"),": put a LEAVE instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putRet()"),": put a RET instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putRetImm(immValue)"),": put a RET instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJmpAddress(address)"),": put a JMP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJmpShortLabel(labelId)"),": put a JMP instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJmpNearLabel(labelId)"),": put a JMP instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJmpReg(reg)"),": put a JMP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJmpRegPtr(reg)"),": put a JMP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJmpRegOffsetPtr(reg, offset)"),": put a JMP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJmpNearPtr(address)"),": put a JMP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJccShort(instructionId, target, hint)"),": put a JCC instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJccNear(instructionId, target, hint)"),": put a JCC instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJccShortLabel(instructionId, labelId, hint)"),": put a JCC instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJccNearLabel(instructionId, labelId, hint)"),": put a JCC instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegImm(reg, immValue)"),": put an ADD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegReg(dstReg, srcReg)"),": put an ADD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegNearPtr(dstReg, srcAddress)"),": put an ADD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegImm(reg, immValue)"),": put a SUB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegReg(dstReg, srcReg)"),": put a SUB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegNearPtr(dstReg, srcAddress)"),": put a SUB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putIncReg(reg)"),": put an INC instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putDecReg(reg)"),": put a DEC instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putIncRegPtr(target, reg)"),": put an INC instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putDecRegPtr(target, reg)"),": put a DEC instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLockXaddRegPtrReg(dstReg, srcReg)"),": put a LOCK XADD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLockCmpxchgRegPtrReg(dstReg, srcReg)"),": put a LOCK CMPXCHG instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLockIncImm32Ptr(target)"),": put a LOCK INC IMM32 instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLockDecImm32Ptr(target)"),": put a LOCK DEC IMM32 instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAndRegReg(dstReg, srcReg)"),": put an AND instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAndRegU32(reg, immValue)"),": put an AND instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putShlRegU8(reg, immValue)"),": put a SHL instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putShrRegU8(reg, immValue)"),": put a SHR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putXorRegReg(dstReg, srcReg)"),": put an XOR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegReg(dstReg, srcReg)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegU32(dstReg, immValue)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegU64(dstReg, immValue)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegAddress(dstReg, address)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegPtrU32(dstReg, immValue)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegOffsetPtrU32(dstReg, dstOffset, immValue)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegPtrReg(dstReg, srcReg)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegOffsetPtrReg(dstReg, dstOffset, srcReg)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegRegPtr(dstReg, srcReg)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegRegOffsetPtr(dstReg, srcReg, srcOffset)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegBaseIndexScaleOffsetPtr(dstReg, baseReg, indexReg, scale, offset)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegNearPtr(dstReg, srcAddress)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovNearPtrReg(dstAddress, srcReg)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovFsU32PtrReg(fsOffset, srcReg)"),": put a MOV FS instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegFsU32Ptr(dstReg, fsOffset)"),": put a MOV FS instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovGsU32PtrReg(fsOffset, srcReg)"),": put a MOV GS instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegGsU32Ptr(dstReg, fsOffset)"),": put a MOV GS instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovqXmm0EspOffsetPtr(offset)"),": put a MOVQ XMM0 ESP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovqEaxOffsetPtrXmm0(offset)"),": put a MOVQ EAX XMM0 instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovdquXmm0EspOffsetPtr(offset)"),": put a MOVDQU XMM0 ESP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovdquEaxOffsetPtrXmm0(offset)"),": put a MOVDQU EAX XMM0 instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLeaRegRegOffset(dstReg, srcReg, srcOffset)"),": put a LEA instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putXchgRegRegPtr(leftReg, rightReg)"),": put an XCHG instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPushU32(immValue)"),": put a PUSH instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPushNearPtr(address)"),": put a PUSH instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPushReg(reg)"),": put a PUSH instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPopReg(reg)"),": put a POP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPushImmPtr(immPtr)"),": put a PUSH instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPushax()"),": put a PUSHAX instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPopax()"),": put a POPAX instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPushfx()"),": put a PUSHFX instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPopfx()"),": put a POPFX instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putTestRegReg(regA, regB)"),": put a TEST instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putTestRegU32(reg, immValue)"),": put a TEST instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCmpRegI32(reg, immValue)"),": put a CMP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCmpRegOffsetPtrReg(regA, offset, regB)"),": put a CMP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCmpImmPtrImmU32(immPtr, immValue)"),": put a CMP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCmpRegReg(regA, regB)"),": put a CMP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putClc()"),": put a CLC instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putStc()"),": put a STC instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCld()"),": put a CLD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putStd()"),": put a STD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCpuid()"),": put a CPUID instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLfence()"),": put an LFENCE instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putRdtsc()"),": put an RDTSC instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPause()"),": put a PAUSE instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putNop()"),": put a NOP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBreakpoint()"),": put an OS/architecture-specific breakpoint instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPadding(n)"),": put ",Object(r.b)("inlineCode",{parentName:"p"},"n")," guard instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putNopPadding(n)"),": put ",Object(r.b)("inlineCode",{parentName:"p"},"n")," NOP instructions")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putU8(value)"),": put a uint8")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putS8(value)"),": put an int8")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBytes(data)"),": put raw data from the provided ArrayBuffer"))),Object(r.b)("h2",{id:"x86relocator"},"X86Relocator"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new X86Relocator(inputCode, output)"),": create a new code relocator for\ncopying x86 instructions from one memory location to another, taking\ncare to adjust position-dependent instructions accordingly.\nThe source address is specified by ",Object(r.b)("inlineCode",{parentName:"li"},"inputCode"),", a NativePointer.\nThe destination is given by ",Object(r.b)("inlineCode",{parentName:"li"},"output"),", an ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#x86writer"}),"X86Writer")," pointed\nat the desired target memory address.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"reset(inputCode, output)"),": recycle instance")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"dispose()"),": eagerly clean up memory")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"input"),": latest ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#instruction"}),"Instruction")," read so far. Starts out ",Object(r.b)("inlineCode",{parentName:"p"},"null"),"\nand changes on every call to ",Object(r.b)("inlineCode",{parentName:"p"},"readOne()"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"eob"),": boolean indicating whether end-of-block has been reached, i.e. we've\nreached a branch of any kind, like CALL, JMP, BL, RET.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"eoi"),": boolean indicating whether end-of-input has been reached, e.g. we've\nreached JMP/B/RET, an instruction after which there may or may not be valid\ncode.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"readOne()"),": read the next instruction into the relocator's internal buffer\nand return the number of bytes read so far, including previous calls.\nYou may keep calling this method to keep buffering, or immediately call\neither ",Object(r.b)("inlineCode",{parentName:"p"},"writeOne()")," or ",Object(r.b)("inlineCode",{parentName:"p"},"skipOne()"),". Or, you can buffer up until the desired\npoint and then call ",Object(r.b)("inlineCode",{parentName:"p"},"writeAll()"),".\nReturns zero when end-of-input is reached, which means the ",Object(r.b)("inlineCode",{parentName:"p"},"eoi")," property is\nnow ",Object(r.b)("inlineCode",{parentName:"p"},"true"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"peekNextWriteInsn()"),": peek at the next ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#instruction"}),"Instruction")," to be\nwritten or skipped")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"peekNextWriteSource()"),": peek at the address of the next instruction to be\nwritten or skipped")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"skipOne()"),": skip the instruction that would have been written next")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"skipOneNoLabel()"),": skip the instruction that would have been written next,\nbut without a label for internal use. This breaks relocation of branches to\nlocations inside the relocated range, and is an optimization for use-cases\nwhere all branches are rewritten (e.g. Frida's Stalker).")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeOne()"),": write the next buffered instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeOneNoLabel()"),": write the next buffered instruction, but without a\nlabel for internal use. This breaks relocation of branches to locations\ninside the relocated range, and is an optimization for use-cases where all\nbranches are rewritten (e.g. Frida's Stalker).")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeAll()"),": write all buffered instructions"))),Object(r.b)("h2",{id:"x86-enum-types"},"x86 enum types"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Register: ",Object(r.b)("inlineCode",{parentName:"li"},"xax")," ",Object(r.b)("inlineCode",{parentName:"li"},"xcx")," ",Object(r.b)("inlineCode",{parentName:"li"},"xdx")," ",Object(r.b)("inlineCode",{parentName:"li"},"xbx")," ",Object(r.b)("inlineCode",{parentName:"li"},"xsp")," ",Object(r.b)("inlineCode",{parentName:"li"},"xbp")," ",Object(r.b)("inlineCode",{parentName:"li"},"xsi")," ",Object(r.b)("inlineCode",{parentName:"li"},"xdi")," ",Object(r.b)("inlineCode",{parentName:"li"},"eax")," ",Object(r.b)("inlineCode",{parentName:"li"},"ecx")," ",Object(r.b)("inlineCode",{parentName:"li"},"edx"),Object(r.b)("inlineCode",{parentName:"li"},"ebx")," ",Object(r.b)("inlineCode",{parentName:"li"},"esp")," ",Object(r.b)("inlineCode",{parentName:"li"},"ebp")," ",Object(r.b)("inlineCode",{parentName:"li"},"esi")," ",Object(r.b)("inlineCode",{parentName:"li"},"edi")," ",Object(r.b)("inlineCode",{parentName:"li"},"rax")," ",Object(r.b)("inlineCode",{parentName:"li"},"rcx")," ",Object(r.b)("inlineCode",{parentName:"li"},"rdx")," ",Object(r.b)("inlineCode",{parentName:"li"},"rbx")," ",Object(r.b)("inlineCode",{parentName:"li"},"rsp")," ",Object(r.b)("inlineCode",{parentName:"li"},"rbp")," ",Object(r.b)("inlineCode",{parentName:"li"},"rsi"),Object(r.b)("inlineCode",{parentName:"li"},"rdi")," ",Object(r.b)("inlineCode",{parentName:"li"},"r8")," ",Object(r.b)("inlineCode",{parentName:"li"},"r9")," ",Object(r.b)("inlineCode",{parentName:"li"},"r10")," ",Object(r.b)("inlineCode",{parentName:"li"},"r11")," ",Object(r.b)("inlineCode",{parentName:"li"},"r12")," ",Object(r.b)("inlineCode",{parentName:"li"},"r13")," ",Object(r.b)("inlineCode",{parentName:"li"},"r14")," ",Object(r.b)("inlineCode",{parentName:"li"},"r15")," ",Object(r.b)("inlineCode",{parentName:"li"},"r8d")," ",Object(r.b)("inlineCode",{parentName:"li"},"r9d")," ",Object(r.b)("inlineCode",{parentName:"li"},"r10d"),Object(r.b)("inlineCode",{parentName:"li"},"r11d")," ",Object(r.b)("inlineCode",{parentName:"li"},"r12d")," ",Object(r.b)("inlineCode",{parentName:"li"},"r13d")," ",Object(r.b)("inlineCode",{parentName:"li"},"r14d")," ",Object(r.b)("inlineCode",{parentName:"li"},"r15d")," ",Object(r.b)("inlineCode",{parentName:"li"},"xip")," ",Object(r.b)("inlineCode",{parentName:"li"},"eip")," ",Object(r.b)("inlineCode",{parentName:"li"},"rip")),Object(r.b)("li",{parentName:"ul"},"InstructionId: ",Object(r.b)("inlineCode",{parentName:"li"},"jo")," ",Object(r.b)("inlineCode",{parentName:"li"},"jno")," ",Object(r.b)("inlineCode",{parentName:"li"},"jb")," ",Object(r.b)("inlineCode",{parentName:"li"},"jae")," ",Object(r.b)("inlineCode",{parentName:"li"},"je")," ",Object(r.b)("inlineCode",{parentName:"li"},"jne")," ",Object(r.b)("inlineCode",{parentName:"li"},"jbe")," ",Object(r.b)("inlineCode",{parentName:"li"},"ja")," ",Object(r.b)("inlineCode",{parentName:"li"},"js")," ",Object(r.b)("inlineCode",{parentName:"li"},"jns")," ",Object(r.b)("inlineCode",{parentName:"li"},"jp"),Object(r.b)("inlineCode",{parentName:"li"},"jnp")," ",Object(r.b)("inlineCode",{parentName:"li"},"jl")," ",Object(r.b)("inlineCode",{parentName:"li"},"jge")," ",Object(r.b)("inlineCode",{parentName:"li"},"jle")," ",Object(r.b)("inlineCode",{parentName:"li"},"jg")," ",Object(r.b)("inlineCode",{parentName:"li"},"jcxz")," ",Object(r.b)("inlineCode",{parentName:"li"},"jecxz")," ",Object(r.b)("inlineCode",{parentName:"li"},"jrcxz")),Object(r.b)("li",{parentName:"ul"},"BranchHint: ",Object(r.b)("inlineCode",{parentName:"li"},"no-hint")," ",Object(r.b)("inlineCode",{parentName:"li"},"likely")," ",Object(r.b)("inlineCode",{parentName:"li"},"unlikely")),Object(r.b)("li",{parentName:"ul"},"PointerTarget: ",Object(r.b)("inlineCode",{parentName:"li"},"byte")," ",Object(r.b)("inlineCode",{parentName:"li"},"dword")," ",Object(r.b)("inlineCode",{parentName:"li"},"qword"))),Object(r.b)("h2",{id:"armwriter"},"ArmWriter"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new ArmWriter(codeAddress[, { pc: ptr('0x1234') }])"),": create a new code\nwriter for generating ARM machine code written directly to memory at\n",Object(r.b)("inlineCode",{parentName:"li"},"codeAddress"),", specified as a NativePointer.\nThe second argument is an optional options object where the initial program\ncounter may be specified, which is useful when generating code to a scratch\nbuffer. This is essential when using ",Object(r.b)("inlineCode",{parentName:"li"},"Memory.patchCode()")," on iOS, which may\nprovide you with a temporary location that later gets mapped into memory at\nthe intended memory location.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"reset(codeAddress[, { pc: ptr('0x1234') }])"),": recycle instance")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"dispose()"),": eagerly clean up memory")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"flush()"),": resolve label references and write pending data to memory. You\nshould always call this once you've finished generating code. It is usually\nalso desirable to do this between pieces of unrelated code, e.g. when\ngenerating multiple functions in one go.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"base"),": memory location of the first byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"code"),": memory location of the next byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"pc"),": program counter at the next byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"offset"),": current offset as a JavaScript Number")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"skip(nBytes)"),": skip ",Object(r.b)("inlineCode",{parentName:"p"},"nBytes"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLabel(id)"),": put a label at the current position, where ",Object(r.b)("inlineCode",{parentName:"p"},"id")," is a string\nthat may be referenced in past and future ",Object(r.b)("inlineCode",{parentName:"p"},"put*Label()")," calls")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallAddressWithArguments(func, args)"),": put code needed for calling a C\nfunction with the specified ",Object(r.b)("inlineCode",{parentName:"p"},"args"),", specified as a JavaScript array where\neach element is either a string specifying the register, or a Number or\nNativePointer specifying the immediate value.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBranchAddress(address)"),": put code needed for branching/jumping to the\ngiven address")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"canBranchDirectlyBetween(from, to)"),": determine whether a direct branch is\npossible between the two given memory locations")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBImm(target)"),": put a B instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBCondImm(cc, target)"),": put a B COND instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBLabel(labelId)"),": put a B instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBCondLabel(cc, labelId)"),": put a B COND instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBlImm(target)"),": put a BL instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBlxImm(target)"),": put a BLX instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBlLabel(labelId)"),": put a BL instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBxReg(reg)"),": put a BX instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBlxReg(reg)"),": put a BLX instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putRet()"),": put a RET instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegAddress(reg, address)"),": put an LDR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegU32(reg, val)"),": put an LDR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegRegOffset(dstReg, srcReg, srcOffset)"),": put an LDR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrCondRegRegOffset(cc, dstReg, srcReg, srcOffset)"),": put an LDR COND instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdmiaRegMask(reg, mask)"),": put an LDMIA MASK instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putStrRegRegOffset(srcReg, dstReg, dstOffset)"),": put a STR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putStrCondRegRegOffset(cc, srcReg, dstReg, dstOffset)"),": put a STR COND instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegReg(dstReg, srcReg)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegRegShift(dstReg, srcReg, shift, shiftValue)"),": put a MOV SHIFT instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegCpsr(reg)"),": put a MOV CPSR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovCpsrReg(reg)"),": put a MOV CPSR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegU16(dstReg, val)"),": put an ADD U16 instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegU32(dstReg, val)"),": put an ADD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegRegImm(dstReg, srcReg, immVal)"),": put an ADD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegRegReg(dstReg, srcReg1, srcReg2)"),": put an ADD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegRegRegShift(dstReg, srcReg1, srcReg2, shift, shiftValue)"),": put an ADD SHIFT instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegU16(dstReg, val)"),": put a SUB U16 instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegU32(dstReg, val)"),": put a SUB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegRegImm(dstReg, srcReg, immVal)"),": put a SUB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegRegReg(dstReg, srcReg1, srcReg2)"),": put a SUB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAndsRegRegImm(dstReg, srcReg, immVal)"),": put an ANDS instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCmpRegImm(dstReg, immVal)"),": put a CMP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putNop()"),": put a NOP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBreakpoint()"),": put an OS/architecture-specific breakpoint instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBrkImm(imm)"),": put a BRK instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putInstruction(insn)"),": put a raw instruction as a JavaScript Number")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBytes(data)"),": put raw data from the provided ArrayBuffer"))),Object(r.b)("h2",{id:"armrelocator"},"ArmRelocator"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new ArmRelocator(inputCode, output)"),": create a new code relocator for\ncopying ARM instructions from one memory location to another, taking\ncare to adjust position-dependent instructions accordingly.\nThe source address is specified by ",Object(r.b)("inlineCode",{parentName:"li"},"inputCode"),", a NativePointer.\nThe destination is given by ",Object(r.b)("inlineCode",{parentName:"li"},"output"),", an ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#armwriter"}),"ArmWriter")," pointed\nat the desired target memory address.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"reset(inputCode, output)"),": recycle instance")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"dispose()"),": eagerly clean up memory")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"input"),": latest ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#instruction"}),"Instruction")," read so far. Starts out ",Object(r.b)("inlineCode",{parentName:"p"},"null"),"\nand changes on every call to ",Object(r.b)("inlineCode",{parentName:"p"},"readOne()"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"eob"),": boolean indicating whether end-of-block has been reached, i.e. we've\nreached a branch of any kind, like CALL, JMP, BL, RET.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"eoi"),": boolean indicating whether end-of-input has been reached, e.g. we've\nreached JMP/B/RET, an instruction after which there may or may not be valid\ncode.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"readOne()"),": read the next instruction into the relocator's internal buffer\nand return the number of bytes read so far, including previous calls.\nYou may keep calling this method to keep buffering, or immediately call\neither ",Object(r.b)("inlineCode",{parentName:"p"},"writeOne()")," or ",Object(r.b)("inlineCode",{parentName:"p"},"skipOne()"),". Or, you can buffer up until the desired\npoint and then call ",Object(r.b)("inlineCode",{parentName:"p"},"writeAll()"),".\nReturns zero when end-of-input is reached, which means the ",Object(r.b)("inlineCode",{parentName:"p"},"eoi")," property is\nnow ",Object(r.b)("inlineCode",{parentName:"p"},"true"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"peekNextWriteInsn()"),": peek at the next ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#instruction"}),"Instruction")," to be\nwritten or skipped")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"peekNextWriteSource()"),": peek at the address of the next instruction to be\nwritten or skipped")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"skipOne()"),": skip the instruction that would have been written next")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeOne()"),": write the next buffered instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeAll()"),": write all buffered instructions"))),Object(r.b)("h2",{id:"thumbwriter"},"ThumbWriter"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new ThumbWriter(codeAddress[, { pc: ptr('0x1234') }])"),": create a new code\nwriter for generating ARM machine code written directly to memory at\n",Object(r.b)("inlineCode",{parentName:"li"},"codeAddress"),", specified as a NativePointer.\nThe second argument is an optional options object where the initial program\ncounter may be specified, which is useful when generating code to a scratch\nbuffer. This is essential when using ",Object(r.b)("inlineCode",{parentName:"li"},"Memory.patchCode()")," on iOS, which may\nprovide you with a temporary location that later gets mapped into memory at\nthe intended memory location.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"reset(codeAddress[, { pc: ptr('0x1234') }])"),": recycle instance")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"dispose()"),": eagerly clean up memory")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"flush()"),": resolve label references and write pending data to memory. You\nshould always call this once you've finished generating code. It is usually\nalso desirable to do this between pieces of unrelated code, e.g. when\ngenerating multiple functions in one go.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"base"),": memory location of the first byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"code"),": memory location of the next byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"pc"),": program counter at the next byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"offset"),": current offset as a JavaScript Number")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"skip(nBytes)"),": skip ",Object(r.b)("inlineCode",{parentName:"p"},"nBytes"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLabel(id)"),": put a label at the current position, where ",Object(r.b)("inlineCode",{parentName:"p"},"id")," is a string\nthat may be referenced in past and future ",Object(r.b)("inlineCode",{parentName:"p"},"put*Label()")," calls")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"commitLabel(id)"),": commit the first pending reference to the given label,\nreturning ",Object(r.b)("inlineCode",{parentName:"p"},"true")," on success. Returns ",Object(r.b)("inlineCode",{parentName:"p"},"false")," if the given label hasn't been\ndefined yet, or there are no more pending references to it.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallAddressWithArguments(func, args)"),": put code needed for calling a C\nfunction with the specified ",Object(r.b)("inlineCode",{parentName:"p"},"args"),", specified as a JavaScript array where\neach element is either a string specifying the register, or a Number or\nNativePointer specifying the immediate value.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallRegWithArguments(reg, args)"),": put code needed for calling a C\nfunction with the specified ",Object(r.b)("inlineCode",{parentName:"p"},"args"),", specified as a JavaScript array where\neach element is either a string specifying the register, or a Number or\nNativePointer specifying the immediate value.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBImm(target)"),": put a B instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBLabel(labelId)"),": put a B instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBLabelWide(labelId)"),": put a B WIDE instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBxReg(reg)"),": put a BX instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBlImm(target)"),": put a BL instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBlLabel(labelId)"),": put a BL instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBlxImm(target)"),": put a BLX instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBlxReg(reg)"),": put a BLX instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCmpRegImm(reg, immValue)"),": put a CMP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBeqLabel(labelId)"),": put a BEQ instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBneLabel(labelId)"),": put a BNE instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBCondLabel(cc, labelId)"),": put a B COND instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBCondLabelWide(cc, labelId)"),": put a B COND WIDE instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCbzRegLabel(reg, labelId)"),": put a CBZ instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCbnzRegLabel(reg, labelId)"),": put a CBNZ instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPushRegs(regs)"),": put a PUSH instruction with the specified registers,\nspecified as a JavaScript array where each element is a string specifying\nthe register name.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPopRegs(regs)"),": put a POP instruction with the specified registers,\nspecified as a JavaScript array where each element is a string specifying\nthe register name.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegAddress(reg, address)"),": put an LDR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegU32(reg, val)"),": put an LDR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegReg(dstReg, srcReg)"),": put an LDR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegRegOffset(dstReg, srcReg, srcOffset)"),": put an LDR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrbRegReg(dstReg, srcReg)"),": put an LDRB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putVldrRegRegOffset(dstReg, srcReg, srcOffset)"),": put a VLDR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdmiaRegMask(reg, mask)"),": put an LDMIA MASK instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putStrRegReg(srcReg, dstReg)"),": put a STR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putStrRegRegOffset(srcReg, dstReg, dstOffset)"),": put a STR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegReg(dstReg, srcReg)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegU8(dstReg, immValue)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegCpsr(reg)"),": put a MOV CPSR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovCpsrReg(reg)"),": put a MOV CPSR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegImm(dstReg, immValue)"),": put an ADD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegReg(dstReg, srcReg)"),": put an ADD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegRegReg(dstReg, leftReg, rightReg)"),": put an ADD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegRegImm(dstReg, leftReg, rightValue)"),": put an ADD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegImm(dstReg, immValue)"),": put a SUB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegReg(dstReg, srcReg)"),": put a SUB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegRegReg(dstReg, leftReg, rightReg)"),": put a SUB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegRegImm(dstReg, leftReg, rightValue)"),": put a SUB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAndRegRegImm(dstReg, leftReg, rightValue)"),": put an AND instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLslsRegRegImm(dstReg, leftReg, rightValue)"),": put a LSLS instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLsrsRegRegImm(dstReg, leftReg, rightValue)"),": put a LSRS instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMrsRegReg(dstReg, srcReg)"),": put a MRS instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMsrRegReg(dstReg, srcReg)"),": put a MSR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putNop()"),": put a NOP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBkptImm(imm)"),": put a BKPT instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBreakpoint()"),": put an OS/architecture-specific breakpoint instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putInstruction(insn)"),": put a raw instruction as a JavaScript Number")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putInstructionWide(upper, lower)"),": put a raw Thumb-2 instruction from\ntwo JavaScript Number values")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBytes(data)"),": put raw data from the provided ArrayBuffer"))),Object(r.b)("h2",{id:"thumbrelocator"},"ThumbRelocator"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new ThumbRelocator(inputCode, output)"),": create a new code relocator for\ncopying ARM instructions from one memory location to another, taking\ncare to adjust position-dependent instructions accordingly.\nThe source address is specified by ",Object(r.b)("inlineCode",{parentName:"li"},"inputCode"),", a NativePointer.\nThe destination is given by ",Object(r.b)("inlineCode",{parentName:"li"},"output"),", a ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#thumbwriter"}),"ThumbWriter")," pointed\nat the desired target memory address.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"reset(inputCode, output)"),": recycle instance")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"dispose()"),": eagerly clean up memory")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"input"),": latest ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#instruction"}),"Instruction")," read so far. Starts out ",Object(r.b)("inlineCode",{parentName:"p"},"null"),"\nand changes on every call to ",Object(r.b)("inlineCode",{parentName:"p"},"readOne()"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"eob"),": boolean indicating whether end-of-block has been reached, i.e. we've\nreached a branch of any kind, like CALL, JMP, BL, RET.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"eoi"),": boolean indicating whether end-of-input has been reached, e.g. we've\nreached JMP/B/RET, an instruction after which there may or may not be valid\ncode.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"readOne()"),": read the next instruction into the relocator's internal buffer\nand return the number of bytes read so far, including previous calls.\nYou may keep calling this method to keep buffering, or immediately call\neither ",Object(r.b)("inlineCode",{parentName:"p"},"writeOne()")," or ",Object(r.b)("inlineCode",{parentName:"p"},"skipOne()"),". Or, you can buffer up until the desired\npoint and then call ",Object(r.b)("inlineCode",{parentName:"p"},"writeAll()"),".\nReturns zero when end-of-input is reached, which means the ",Object(r.b)("inlineCode",{parentName:"p"},"eoi")," property is\nnow ",Object(r.b)("inlineCode",{parentName:"p"},"true"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"peekNextWriteInsn()"),": peek at the next ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#instruction"}),"Instruction")," to be\nwritten or skipped")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"peekNextWriteSource()"),": peek at the address of the next instruction to be\nwritten or skipped")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"skipOne()"),": skip the instruction that would have been written next")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeOne()"),": write the next buffered instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"copyOne()"),": copy out the next buffered instruction without advancing the\noutput cursor, allowing the same instruction to be written out multiple\ntimes")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeAll()"),": write all buffered instructions"))),Object(r.b)("h2",{id:"arm-enum-types"},"ARM enum types"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Register: ",Object(r.b)("inlineCode",{parentName:"li"},"r0")," ",Object(r.b)("inlineCode",{parentName:"li"},"r1")," ",Object(r.b)("inlineCode",{parentName:"li"},"r2")," ",Object(r.b)("inlineCode",{parentName:"li"},"r3")," ",Object(r.b)("inlineCode",{parentName:"li"},"r4")," ",Object(r.b)("inlineCode",{parentName:"li"},"r5")," ",Object(r.b)("inlineCode",{parentName:"li"},"r6")," ",Object(r.b)("inlineCode",{parentName:"li"},"r7")," ",Object(r.b)("inlineCode",{parentName:"li"},"r8")," ",Object(r.b)("inlineCode",{parentName:"li"},"r9")," ",Object(r.b)("inlineCode",{parentName:"li"},"r10")," ",Object(r.b)("inlineCode",{parentName:"li"},"r11"),Object(r.b)("inlineCode",{parentName:"li"},"r12")," ",Object(r.b)("inlineCode",{parentName:"li"},"r13")," ",Object(r.b)("inlineCode",{parentName:"li"},"r14")," ",Object(r.b)("inlineCode",{parentName:"li"},"r15")," ",Object(r.b)("inlineCode",{parentName:"li"},"sp")," ",Object(r.b)("inlineCode",{parentName:"li"},"lr")," ",Object(r.b)("inlineCode",{parentName:"li"},"sb")," ",Object(r.b)("inlineCode",{parentName:"li"},"sl")," ",Object(r.b)("inlineCode",{parentName:"li"},"fp")," ",Object(r.b)("inlineCode",{parentName:"li"},"ip")," ",Object(r.b)("inlineCode",{parentName:"li"},"pc")),Object(r.b)("li",{parentName:"ul"},"SystemRegister: ",Object(r.b)("inlineCode",{parentName:"li"},"apsr-nzcvq")),Object(r.b)("li",{parentName:"ul"},"ConditionCode: ",Object(r.b)("inlineCode",{parentName:"li"},"eq")," ",Object(r.b)("inlineCode",{parentName:"li"},"ne")," ",Object(r.b)("inlineCode",{parentName:"li"},"hs")," ",Object(r.b)("inlineCode",{parentName:"li"},"lo")," ",Object(r.b)("inlineCode",{parentName:"li"},"mi")," ",Object(r.b)("inlineCode",{parentName:"li"},"pl")," ",Object(r.b)("inlineCode",{parentName:"li"},"vs")," ",Object(r.b)("inlineCode",{parentName:"li"},"vc")," ",Object(r.b)("inlineCode",{parentName:"li"},"hi")," ",Object(r.b)("inlineCode",{parentName:"li"},"ls")," ",Object(r.b)("inlineCode",{parentName:"li"},"ge")," ",Object(r.b)("inlineCode",{parentName:"li"},"lt"),Object(r.b)("inlineCode",{parentName:"li"},"gt")," ",Object(r.b)("inlineCode",{parentName:"li"},"le")," ",Object(r.b)("inlineCode",{parentName:"li"},"al")),Object(r.b)("li",{parentName:"ul"},"Shifter: ",Object(r.b)("inlineCode",{parentName:"li"},"asr")," ",Object(r.b)("inlineCode",{parentName:"li"},"lsl")," ",Object(r.b)("inlineCode",{parentName:"li"},"lsr")," ",Object(r.b)("inlineCode",{parentName:"li"},"ror")," ",Object(r.b)("inlineCode",{parentName:"li"},"rrx")," ",Object(r.b)("inlineCode",{parentName:"li"},"asr-reg")," ",Object(r.b)("inlineCode",{parentName:"li"},"lsl-reg")," ",Object(r.b)("inlineCode",{parentName:"li"},"lsr-reg"),Object(r.b)("inlineCode",{parentName:"li"},"ror-reg")," ",Object(r.b)("inlineCode",{parentName:"li"},"rrx-reg"))),Object(r.b)("h2",{id:"arm64writer"},"Arm64Writer"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new Arm64Writer(codeAddress[, { pc: ptr('0x1234') }])"),": create a new code\nwriter for generating AArch64 machine code written directly to memory at\n",Object(r.b)("inlineCode",{parentName:"li"},"codeAddress"),", specified as a NativePointer.\nThe second argument is an optional options object where the initial program\ncounter may be specified, which is useful when generating code to a scratch\nbuffer. This is essential when using ",Object(r.b)("inlineCode",{parentName:"li"},"Memory.patchCode()")," on iOS, which may\nprovide you with a temporary location that later gets mapped into memory at\nthe intended memory location.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"reset(codeAddress[, { pc: ptr('0x1234') }])"),": recycle instance")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"dispose()"),": eagerly clean up memory")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"flush()"),": resolve label references and write pending data to memory. You\nshould always call this once you've finished generating code. It is usually\nalso desirable to do this between pieces of unrelated code, e.g. when\ngenerating multiple functions in one go.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"base"),": memory location of the first byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"code"),": memory location of the next byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"pc"),": program counter at the next byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"offset"),": current offset as a JavaScript Number")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"skip(nBytes)"),": skip ",Object(r.b)("inlineCode",{parentName:"p"},"nBytes"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLabel(id)"),": put a label at the current position, where ",Object(r.b)("inlineCode",{parentName:"p"},"id")," is a string\nthat may be referenced in past and future ",Object(r.b)("inlineCode",{parentName:"p"},"put*Label()")," calls")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallAddressWithArguments(func, args)"),": put code needed for calling a C\nfunction with the specified ",Object(r.b)("inlineCode",{parentName:"p"},"args"),", specified as a JavaScript array where\neach element is either a string specifying the register, or a Number or\nNativePointer specifying the immediate value.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallRegWithArguments(reg, args)"),": put code needed for calling a C\nfunction with the specified ",Object(r.b)("inlineCode",{parentName:"p"},"args"),", specified as a JavaScript array where\neach element is either a string specifying the register, or a Number or\nNativePointer specifying the immediate value.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBranchAddress(address)"),": put code needed for branching/jumping to the\ngiven address")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"canBranchDirectlyBetween(from, to)"),": determine whether a direct branch is\npossible between the two given memory locations")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBImm(address)"),": put a B instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBLabel(labelId)"),": put a B instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBCondLabel(cc, labelId)"),": put a B COND instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBlImm(address)"),": put a BL instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBlLabel(labelId)"),": put a BL instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBrReg(reg)"),": put a BR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBrRegNoAuth(reg)"),": put a BR instruction expecting a raw pointer\nwithout any authentication bits")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBlrReg(reg)"),": put a BLR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBlrRegNoAuth(reg)"),": put a BLR instruction expecting a raw pointer\nwithout any authentication bits")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putRet()"),": put a RET instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCbzRegLabel(reg, labelId)"),": put a CBZ instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCbnzRegLabel(reg, labelId)"),": put a CBNZ instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putTbzRegImmLabel(reg, bit, labelId)"),": put a TBZ instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putTbnzRegImmLabel(reg, bit, labelId)"),": put a TBNZ instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPushRegReg(regA, regB)"),": put a PUSH instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPopRegReg(regA, regB)"),": put a POP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPushAllXRegisters()"),": put code needed for pushing all X registers on the stack")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPopAllXRegisters()"),": put code needed for popping all X registers off the stack")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPushAllQRegisters()"),": put code needed for pushing all Q registers on the stack")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPopAllQRegisters()"),": put code needed for popping all Q registers off the stack")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegAddress(reg, address)"),": put an LDR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegU64(reg, val)"),": put an LDR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegRef(reg)"),": put an LDR instruction with a dangling data reference,\nreturning an opaque ref value that should be passed to ",Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegValue()"),"\nat the desired location")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegValue(ref, value)"),": put the value and update the LDR instruction\nfrom a previous ",Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegRef()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrRegRegOffset(dstReg, srcReg, srcOffset)"),": put an LDR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdrswRegRegOffset(dstReg, srcReg, srcOffset)"),": put an LDRSW instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAdrpRegAddress(reg, address)"),": put an ADRP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putStrRegRegOffset(srcReg, dstReg, dstOffset)"),": put a STR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdpRegRegRegOffset(regA, regB, regSrc, srcOffset, mode)"),": put an LDP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putStpRegRegRegOffset(regA, regB, regDst, dstOffset, mode)"),": put a STP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMovRegReg(dstReg, srcReg)"),": put a MOV instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putUxtwRegReg(dstReg, srcReg)"),": put an UXTW instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegRegImm(dstReg, leftReg, rightValue)"),": put an ADD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddRegRegReg(dstReg, leftReg, rightReg)"),": put an ADD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegRegImm(dstReg, leftReg, rightValue)"),": put a SUB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegRegReg(dstReg, leftReg, rightReg)"),": put a SUB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAndRegRegImm(dstReg, leftReg, rightValue)"),": put an AND instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putTstRegImm(reg, immValue)"),": put a TST instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCmpRegReg(regA, regB)"),": put a CMP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putXpaciReg(reg)"),": put an XPACI instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putNop()"),": put a NOP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBrkImm(imm)"),": put a BRK instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putInstruction(insn)"),": put a raw instruction as a JavaScript Number")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBytes(data)"),": put raw data from the provided ArrayBuffer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"sign(value)"),": sign the given pointer value"))),Object(r.b)("h2",{id:"arm64relocator"},"Arm64Relocator"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new Arm64Relocator(inputCode, output)"),": create a new code relocator for\ncopying AArch64 instructions from one memory location to another, taking\ncare to adjust position-dependent instructions accordingly.\nThe source address is specified by ",Object(r.b)("inlineCode",{parentName:"li"},"inputCode"),", a NativePointer.\nThe destination is given by ",Object(r.b)("inlineCode",{parentName:"li"},"output"),", an ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#arm64writer"}),"Arm64Writer")," pointed\nat the desired target memory address.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"reset(inputCode, output)"),": recycle instance")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"dispose()"),": eagerly clean up memory")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"input"),": latest ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#instruction"}),"Instruction")," read so far. Starts out ",Object(r.b)("inlineCode",{parentName:"p"},"null"),"\nand changes on every call to ",Object(r.b)("inlineCode",{parentName:"p"},"readOne()"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"eob"),": boolean indicating whether end-of-block has been reached, i.e. we've\nreached a branch of any kind, like CALL, JMP, BL, RET.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"eoi"),": boolean indicating whether end-of-input has been reached, e.g. we've\nreached JMP/B/RET, an instruction after which there may or may not be valid\ncode.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"readOne()"),": read the next instruction into the relocator's internal buffer\nand return the number of bytes read so far, including previous calls.\nYou may keep calling this method to keep buffering, or immediately call\neither ",Object(r.b)("inlineCode",{parentName:"p"},"writeOne()")," or ",Object(r.b)("inlineCode",{parentName:"p"},"skipOne()"),". Or, you can buffer up until the desired\npoint and then call ",Object(r.b)("inlineCode",{parentName:"p"},"writeAll()"),".\nReturns zero when end-of-input is reached, which means the ",Object(r.b)("inlineCode",{parentName:"p"},"eoi")," property is\nnow ",Object(r.b)("inlineCode",{parentName:"p"},"true"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"peekNextWriteInsn()"),": peek at the next ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#instruction"}),"Instruction")," to be\nwritten or skipped")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"peekNextWriteSource()"),": peek at the address of the next instruction to be\nwritten or skipped")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"skipOne()"),": skip the instruction that would have been written next")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeOne()"),": write the next buffered instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeAll()"),": write all buffered instructions"))),Object(r.b)("h2",{id:"aarch64-enum-types"},"AArch64 enum types"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Register: ",Object(r.b)("inlineCode",{parentName:"li"},"x0")," ",Object(r.b)("inlineCode",{parentName:"li"},"x1")," ",Object(r.b)("inlineCode",{parentName:"li"},"x2")," ",Object(r.b)("inlineCode",{parentName:"li"},"x3")," ",Object(r.b)("inlineCode",{parentName:"li"},"x4")," ",Object(r.b)("inlineCode",{parentName:"li"},"x5")," ",Object(r.b)("inlineCode",{parentName:"li"},"x6")," ",Object(r.b)("inlineCode",{parentName:"li"},"x7")," ",Object(r.b)("inlineCode",{parentName:"li"},"x8")," ",Object(r.b)("inlineCode",{parentName:"li"},"x9")," ",Object(r.b)("inlineCode",{parentName:"li"},"x10")," ",Object(r.b)("inlineCode",{parentName:"li"},"x11"),Object(r.b)("inlineCode",{parentName:"li"},"x12")," ",Object(r.b)("inlineCode",{parentName:"li"},"x13")," ",Object(r.b)("inlineCode",{parentName:"li"},"x14")," ",Object(r.b)("inlineCode",{parentName:"li"},"x15")," ",Object(r.b)("inlineCode",{parentName:"li"},"x16")," ",Object(r.b)("inlineCode",{parentName:"li"},"x17")," ",Object(r.b)("inlineCode",{parentName:"li"},"x18")," ",Object(r.b)("inlineCode",{parentName:"li"},"x19")," ",Object(r.b)("inlineCode",{parentName:"li"},"x20")," ",Object(r.b)("inlineCode",{parentName:"li"},"x21")," ",Object(r.b)("inlineCode",{parentName:"li"},"x22")," ",Object(r.b)("inlineCode",{parentName:"li"},"x23"),Object(r.b)("inlineCode",{parentName:"li"},"x24")," ",Object(r.b)("inlineCode",{parentName:"li"},"x25")," ",Object(r.b)("inlineCode",{parentName:"li"},"x26")," ",Object(r.b)("inlineCode",{parentName:"li"},"x27")," ",Object(r.b)("inlineCode",{parentName:"li"},"x28")," ",Object(r.b)("inlineCode",{parentName:"li"},"x29")," ",Object(r.b)("inlineCode",{parentName:"li"},"x30")," ",Object(r.b)("inlineCode",{parentName:"li"},"w0")," ",Object(r.b)("inlineCode",{parentName:"li"},"w1")," ",Object(r.b)("inlineCode",{parentName:"li"},"w2")," ",Object(r.b)("inlineCode",{parentName:"li"},"w3")," ",Object(r.b)("inlineCode",{parentName:"li"},"w4")," ",Object(r.b)("inlineCode",{parentName:"li"},"w5"),Object(r.b)("inlineCode",{parentName:"li"},"w6")," ",Object(r.b)("inlineCode",{parentName:"li"},"w7")," ",Object(r.b)("inlineCode",{parentName:"li"},"w8")," ",Object(r.b)("inlineCode",{parentName:"li"},"w9")," ",Object(r.b)("inlineCode",{parentName:"li"},"w10")," ",Object(r.b)("inlineCode",{parentName:"li"},"w11")," ",Object(r.b)("inlineCode",{parentName:"li"},"w12")," ",Object(r.b)("inlineCode",{parentName:"li"},"w13")," ",Object(r.b)("inlineCode",{parentName:"li"},"w14")," ",Object(r.b)("inlineCode",{parentName:"li"},"w15")," ",Object(r.b)("inlineCode",{parentName:"li"},"w16")," ",Object(r.b)("inlineCode",{parentName:"li"},"w17")," ",Object(r.b)("inlineCode",{parentName:"li"},"w18"),Object(r.b)("inlineCode",{parentName:"li"},"w19")," ",Object(r.b)("inlineCode",{parentName:"li"},"w20")," ",Object(r.b)("inlineCode",{parentName:"li"},"w21")," ",Object(r.b)("inlineCode",{parentName:"li"},"w22")," ",Object(r.b)("inlineCode",{parentName:"li"},"w23")," ",Object(r.b)("inlineCode",{parentName:"li"},"w24")," ",Object(r.b)("inlineCode",{parentName:"li"},"w25")," ",Object(r.b)("inlineCode",{parentName:"li"},"w26")," ",Object(r.b)("inlineCode",{parentName:"li"},"w27")," ",Object(r.b)("inlineCode",{parentName:"li"},"w28")," ",Object(r.b)("inlineCode",{parentName:"li"},"w29")," ",Object(r.b)("inlineCode",{parentName:"li"},"w30"),Object(r.b)("inlineCode",{parentName:"li"},"sp")," ",Object(r.b)("inlineCode",{parentName:"li"},"lr")," ",Object(r.b)("inlineCode",{parentName:"li"},"fp")," ",Object(r.b)("inlineCode",{parentName:"li"},"wsp")," ",Object(r.b)("inlineCode",{parentName:"li"},"wzr")," ",Object(r.b)("inlineCode",{parentName:"li"},"xzr")," ",Object(r.b)("inlineCode",{parentName:"li"},"nzcv")," ",Object(r.b)("inlineCode",{parentName:"li"},"ip0")," ",Object(r.b)("inlineCode",{parentName:"li"},"ip1")," ",Object(r.b)("inlineCode",{parentName:"li"},"s0")," ",Object(r.b)("inlineCode",{parentName:"li"},"s1")," ",Object(r.b)("inlineCode",{parentName:"li"},"s2")," ",Object(r.b)("inlineCode",{parentName:"li"},"s3"),Object(r.b)("inlineCode",{parentName:"li"},"s4")," ",Object(r.b)("inlineCode",{parentName:"li"},"s5")," ",Object(r.b)("inlineCode",{parentName:"li"},"s6")," ",Object(r.b)("inlineCode",{parentName:"li"},"s7")," ",Object(r.b)("inlineCode",{parentName:"li"},"s8")," ",Object(r.b)("inlineCode",{parentName:"li"},"s9")," ",Object(r.b)("inlineCode",{parentName:"li"},"s10")," ",Object(r.b)("inlineCode",{parentName:"li"},"s11")," ",Object(r.b)("inlineCode",{parentName:"li"},"s12")," ",Object(r.b)("inlineCode",{parentName:"li"},"s13")," ",Object(r.b)("inlineCode",{parentName:"li"},"s14")," ",Object(r.b)("inlineCode",{parentName:"li"},"s15")," ",Object(r.b)("inlineCode",{parentName:"li"},"s16"),Object(r.b)("inlineCode",{parentName:"li"},"s17")," ",Object(r.b)("inlineCode",{parentName:"li"},"s18")," ",Object(r.b)("inlineCode",{parentName:"li"},"s19")," ",Object(r.b)("inlineCode",{parentName:"li"},"s20")," ",Object(r.b)("inlineCode",{parentName:"li"},"s21")," ",Object(r.b)("inlineCode",{parentName:"li"},"s22")," ",Object(r.b)("inlineCode",{parentName:"li"},"s23")," ",Object(r.b)("inlineCode",{parentName:"li"},"s24")," ",Object(r.b)("inlineCode",{parentName:"li"},"s25")," ",Object(r.b)("inlineCode",{parentName:"li"},"s26")," ",Object(r.b)("inlineCode",{parentName:"li"},"s27")," ",Object(r.b)("inlineCode",{parentName:"li"},"s28"),Object(r.b)("inlineCode",{parentName:"li"},"s29")," ",Object(r.b)("inlineCode",{parentName:"li"},"s30")," ",Object(r.b)("inlineCode",{parentName:"li"},"s31")," ",Object(r.b)("inlineCode",{parentName:"li"},"d0")," ",Object(r.b)("inlineCode",{parentName:"li"},"d1")," ",Object(r.b)("inlineCode",{parentName:"li"},"d2")," ",Object(r.b)("inlineCode",{parentName:"li"},"d3")," ",Object(r.b)("inlineCode",{parentName:"li"},"d4")," ",Object(r.b)("inlineCode",{parentName:"li"},"d5")," ",Object(r.b)("inlineCode",{parentName:"li"},"d6")," ",Object(r.b)("inlineCode",{parentName:"li"},"d7")," ",Object(r.b)("inlineCode",{parentName:"li"},"d8")," ",Object(r.b)("inlineCode",{parentName:"li"},"d9")," ",Object(r.b)("inlineCode",{parentName:"li"},"d10"),Object(r.b)("inlineCode",{parentName:"li"},"d11")," ",Object(r.b)("inlineCode",{parentName:"li"},"d12")," ",Object(r.b)("inlineCode",{parentName:"li"},"d13")," ",Object(r.b)("inlineCode",{parentName:"li"},"d14")," ",Object(r.b)("inlineCode",{parentName:"li"},"d15")," ",Object(r.b)("inlineCode",{parentName:"li"},"d16")," ",Object(r.b)("inlineCode",{parentName:"li"},"d17")," ",Object(r.b)("inlineCode",{parentName:"li"},"d18")," ",Object(r.b)("inlineCode",{parentName:"li"},"d19")," ",Object(r.b)("inlineCode",{parentName:"li"},"d20")," ",Object(r.b)("inlineCode",{parentName:"li"},"d21")," ",Object(r.b)("inlineCode",{parentName:"li"},"d22"),Object(r.b)("inlineCode",{parentName:"li"},"d23")," ",Object(r.b)("inlineCode",{parentName:"li"},"d24")," ",Object(r.b)("inlineCode",{parentName:"li"},"d25")," ",Object(r.b)("inlineCode",{parentName:"li"},"d26")," ",Object(r.b)("inlineCode",{parentName:"li"},"d27")," ",Object(r.b)("inlineCode",{parentName:"li"},"d28")," ",Object(r.b)("inlineCode",{parentName:"li"},"d29")," ",Object(r.b)("inlineCode",{parentName:"li"},"d30")," ",Object(r.b)("inlineCode",{parentName:"li"},"d31")," ",Object(r.b)("inlineCode",{parentName:"li"},"q0")," ",Object(r.b)("inlineCode",{parentName:"li"},"q1")," ",Object(r.b)("inlineCode",{parentName:"li"},"q2")," ",Object(r.b)("inlineCode",{parentName:"li"},"q3"),Object(r.b)("inlineCode",{parentName:"li"},"q4")," ",Object(r.b)("inlineCode",{parentName:"li"},"q5")," ",Object(r.b)("inlineCode",{parentName:"li"},"q6")," ",Object(r.b)("inlineCode",{parentName:"li"},"q7")," ",Object(r.b)("inlineCode",{parentName:"li"},"q8")," ",Object(r.b)("inlineCode",{parentName:"li"},"q9")," ",Object(r.b)("inlineCode",{parentName:"li"},"q10")," ",Object(r.b)("inlineCode",{parentName:"li"},"q11")," ",Object(r.b)("inlineCode",{parentName:"li"},"q12")," ",Object(r.b)("inlineCode",{parentName:"li"},"q13")," ",Object(r.b)("inlineCode",{parentName:"li"},"q14")," ",Object(r.b)("inlineCode",{parentName:"li"},"q15")," ",Object(r.b)("inlineCode",{parentName:"li"},"q16"),Object(r.b)("inlineCode",{parentName:"li"},"q17")," ",Object(r.b)("inlineCode",{parentName:"li"},"q18")," ",Object(r.b)("inlineCode",{parentName:"li"},"q19")," ",Object(r.b)("inlineCode",{parentName:"li"},"q20")," ",Object(r.b)("inlineCode",{parentName:"li"},"q21")," ",Object(r.b)("inlineCode",{parentName:"li"},"q22")," ",Object(r.b)("inlineCode",{parentName:"li"},"q23")," ",Object(r.b)("inlineCode",{parentName:"li"},"q24")," ",Object(r.b)("inlineCode",{parentName:"li"},"q25")," ",Object(r.b)("inlineCode",{parentName:"li"},"q26")," ",Object(r.b)("inlineCode",{parentName:"li"},"q27")," ",Object(r.b)("inlineCode",{parentName:"li"},"q28"),Object(r.b)("inlineCode",{parentName:"li"},"q29")," ",Object(r.b)("inlineCode",{parentName:"li"},"q30")," ",Object(r.b)("inlineCode",{parentName:"li"},"q31")),Object(r.b)("li",{parentName:"ul"},"ConditionCode: ",Object(r.b)("inlineCode",{parentName:"li"},"eq")," ",Object(r.b)("inlineCode",{parentName:"li"},"ne")," ",Object(r.b)("inlineCode",{parentName:"li"},"hs")," ",Object(r.b)("inlineCode",{parentName:"li"},"lo")," ",Object(r.b)("inlineCode",{parentName:"li"},"mi")," ",Object(r.b)("inlineCode",{parentName:"li"},"pl")," ",Object(r.b)("inlineCode",{parentName:"li"},"vs")," ",Object(r.b)("inlineCode",{parentName:"li"},"vc")," ",Object(r.b)("inlineCode",{parentName:"li"},"hi")," ",Object(r.b)("inlineCode",{parentName:"li"},"ls")," ",Object(r.b)("inlineCode",{parentName:"li"},"ge")," ",Object(r.b)("inlineCode",{parentName:"li"},"lt"),Object(r.b)("inlineCode",{parentName:"li"},"gt")," ",Object(r.b)("inlineCode",{parentName:"li"},"le")," ",Object(r.b)("inlineCode",{parentName:"li"},"al")," ",Object(r.b)("inlineCode",{parentName:"li"},"nv")),Object(r.b)("li",{parentName:"ul"},"IndexMode: ",Object(r.b)("inlineCode",{parentName:"li"},"post-adjust")," ",Object(r.b)("inlineCode",{parentName:"li"},"signed-offset")," ",Object(r.b)("inlineCode",{parentName:"li"},"pre-adjust"))),Object(r.b)("h2",{id:"mipswriter"},"MipsWriter"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new MipsWriter(codeAddress[, { pc: ptr('0x1234') }])"),": create a new code\nwriter for generating MIPS machine code written directly to memory at\n",Object(r.b)("inlineCode",{parentName:"li"},"codeAddress"),", specified as a NativePointer.\nThe second argument is an optional options object where the initial program\ncounter may be specified, which is useful when generating code to a scratch\nbuffer. This is essential when using ",Object(r.b)("inlineCode",{parentName:"li"},"Memory.patchCode()")," on iOS, which may\nprovide you with a temporary location that later gets mapped into memory at\nthe intended memory location.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"reset(codeAddress[, { pc: ptr('0x1234') }])"),": recycle instance")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"dispose()"),": eagerly clean up memory")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"flush()"),": resolve label references and write pending data to memory. You\nshould always call this once you've finished generating code. It is usually\nalso desirable to do this between pieces of unrelated code, e.g. when\ngenerating multiple functions in one go.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"base"),": memory location of the first byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"code"),": memory location of the next byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"pc"),": program counter at the next byte of output, as a NativePointer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"offset"),": current offset as a JavaScript Number")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"skip(nBytes)"),": skip ",Object(r.b)("inlineCode",{parentName:"p"},"nBytes"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLabel(id)"),": put a label at the current position, where ",Object(r.b)("inlineCode",{parentName:"p"},"id")," is a string\nthat may be referenced in past and future ",Object(r.b)("inlineCode",{parentName:"p"},"put*Label()")," calls")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallAddressWithArguments(func, args)"),": put code needed for calling a C\nfunction with the specified ",Object(r.b)("inlineCode",{parentName:"p"},"args"),", specified as a JavaScript array where\neach element is either a string specifying the register, or a Number or\nNativePointer specifying the immediate value.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putCallRegWithArguments(reg, args)"),": put code needed for calling a C\nfunction with the specified ",Object(r.b)("inlineCode",{parentName:"p"},"args"),", specified as a JavaScript array where\neach element is either a string specifying the register, or a Number or\nNativePointer specifying the immediate value.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJAddress(address)"),": put a J instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJAddressWithoutNop(address)"),": put a J WITHOUT NOP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJLabel(labelId)"),": put a J instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJrReg(reg)"),": put a JR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJalAddress(address)"),": put a JAL instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putJalrReg(reg)"),": put a JALR instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBOffset(offset)"),": put a B instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBeqRegRegLabel(rightReg, leftReg, labelId)"),": put a BEQ instruction\nreferencing ",Object(r.b)("inlineCode",{parentName:"p"},"labelId"),", defined by a past or future ",Object(r.b)("inlineCode",{parentName:"p"},"putLabel()"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putRet()"),": put a RET instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLaRegAddress(reg, address)"),": put a LA instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLuiRegImm(reg, imm)"),": put a LUI instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putDsllRegReg(dstReg, srcReg, amount)"),": put a DSLL instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putOriRegRegImm(rt, rs, imm)"),": put an ORI instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLdRegRegOffset(dstReg, srcReg, srcOffset)"),": put an LD instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putLwRegRegOffset(dstReg, srcReg, srcOffset)"),": put a LW instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSwRegRegOffset(srcReg, dstReg, dstOffset)"),": put a SW instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMoveRegReg(dstReg, srcReg)"),": put a MOVE instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAdduRegRegReg(dstReg, leftReg, rightReg)"),": put an ADDU instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddiRegRegImm(dstReg, leftReg, imm)"),": put an ADDI instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putAddiRegImm(dstReg, imm)"),": put an ADDI instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putSubRegRegImm(dstReg, leftReg, imm)"),": put a SUB instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPushReg(reg)"),": put a PUSH instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPopReg(reg)"),": put a POP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMfhiReg(reg)"),": put a MFHI instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMfloReg(reg)"),": put a MFLO instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMthiReg(reg)"),": put a MTHI instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putMtloReg(reg)"),": put a MTLO instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putNop()"),": put a NOP instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBreak()"),": put a BREAK instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putPrologueTrampoline(reg, address)"),": put a minimal sized trampoline for\nvectoring to the given address")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putInstruction(insn)"),": put a raw instruction as a JavaScript Number")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"putBytes(data)"),": put raw data from the provided ArrayBuffer"))),Object(r.b)("h2",{id:"mipsrelocator"},"MipsRelocator"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"new MipsRelocator(inputCode, output)"),": create a new code relocator for\ncopying MIPS instructions from one memory location to another, taking\ncare to adjust position-dependent instructions accordingly.\nThe source address is specified by ",Object(r.b)("inlineCode",{parentName:"li"},"inputCode"),", a NativePointer.\nThe destination is given by ",Object(r.b)("inlineCode",{parentName:"li"},"output"),", a ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#mipswriter"}),"MipsWriter")," pointed\nat the desired target memory address.")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"reset(inputCode, output)"),": recycle instance")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"dispose()"),": eagerly clean up memory")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"input"),": latest ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#instruction"}),"Instruction")," read so far. Starts out ",Object(r.b)("inlineCode",{parentName:"p"},"null"),"\nand changes on every call to ",Object(r.b)("inlineCode",{parentName:"p"},"readOne()"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"eob"),": boolean indicating whether end-of-block has been reached, i.e. we've\nreached a branch of any kind, like CALL, JMP, BL, RET.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"eoi"),": boolean indicating whether end-of-input has been reached, e.g. we've\nreached JMP/B/RET, an instruction after which there may or may not be valid\ncode.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"readOne()"),": read the next instruction into the relocator's internal buffer\nand return the number of bytes read so far, including previous calls.\nYou may keep calling this method to keep buffering, or immediately call\neither ",Object(r.b)("inlineCode",{parentName:"p"},"writeOne()")," or ",Object(r.b)("inlineCode",{parentName:"p"},"skipOne()"),". Or, you can buffer up until the desired\npoint and then call ",Object(r.b)("inlineCode",{parentName:"p"},"writeAll()"),".\nReturns zero when end-of-input is reached, which means the ",Object(r.b)("inlineCode",{parentName:"p"},"eoi")," property is\nnow ",Object(r.b)("inlineCode",{parentName:"p"},"true"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"peekNextWriteInsn()"),": peek at the next ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#instruction"}),"Instruction")," to be\nwritten or skipped")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"peekNextWriteSource()"),": peek at the address of the next instruction to be\nwritten or skipped")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"skipOne()"),": skip the instruction that would have been written next")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeOne()"),": write the next buffered instruction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"writeAll()"),": write all buffered instructions"))),Object(r.b)("h2",{id:"mips-enum-types"},"MIPS enum types"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Register: ",Object(r.b)("inlineCode",{parentName:"li"},"v0")," ",Object(r.b)("inlineCode",{parentName:"li"},"v1")," ",Object(r.b)("inlineCode",{parentName:"li"},"a0")," ",Object(r.b)("inlineCode",{parentName:"li"},"a1")," ",Object(r.b)("inlineCode",{parentName:"li"},"a2")," ",Object(r.b)("inlineCode",{parentName:"li"},"a3")," ",Object(r.b)("inlineCode",{parentName:"li"},"t0")," ",Object(r.b)("inlineCode",{parentName:"li"},"t1")," ",Object(r.b)("inlineCode",{parentName:"li"},"t2")," ",Object(r.b)("inlineCode",{parentName:"li"},"t3")," ",Object(r.b)("inlineCode",{parentName:"li"},"t4")," ",Object(r.b)("inlineCode",{parentName:"li"},"t5")," ",Object(r.b)("inlineCode",{parentName:"li"},"t6"),Object(r.b)("inlineCode",{parentName:"li"},"t7")," ",Object(r.b)("inlineCode",{parentName:"li"},"s0")," ",Object(r.b)("inlineCode",{parentName:"li"},"s1")," ",Object(r.b)("inlineCode",{parentName:"li"},"s2")," ",Object(r.b)("inlineCode",{parentName:"li"},"s3")," ",Object(r.b)("inlineCode",{parentName:"li"},"s4")," ",Object(r.b)("inlineCode",{parentName:"li"},"s5")," ",Object(r.b)("inlineCode",{parentName:"li"},"s6")," ",Object(r.b)("inlineCode",{parentName:"li"},"s7")," ",Object(r.b)("inlineCode",{parentName:"li"},"t8")," ",Object(r.b)("inlineCode",{parentName:"li"},"t9")," ",Object(r.b)("inlineCode",{parentName:"li"},"k0")," ",Object(r.b)("inlineCode",{parentName:"li"},"k1")," ",Object(r.b)("inlineCode",{parentName:"li"},"gp")," ",Object(r.b)("inlineCode",{parentName:"li"},"sp"),Object(r.b)("inlineCode",{parentName:"li"},"fp")," ",Object(r.b)("inlineCode",{parentName:"li"},"s8")," ",Object(r.b)("inlineCode",{parentName:"li"},"ra")," ",Object(r.b)("inlineCode",{parentName:"li"},"hi")," ",Object(r.b)("inlineCode",{parentName:"li"},"lo")," ",Object(r.b)("inlineCode",{parentName:"li"},"zero")," ",Object(r.b)("inlineCode",{parentName:"li"},"at")," ",Object(r.b)("inlineCode",{parentName:"li"},"0")," ",Object(r.b)("inlineCode",{parentName:"li"},"1")," ",Object(r.b)("inlineCode",{parentName:"li"},"2")," ",Object(r.b)("inlineCode",{parentName:"li"},"3")," ",Object(r.b)("inlineCode",{parentName:"li"},"4")," ",Object(r.b)("inlineCode",{parentName:"li"},"5")," ",Object(r.b)("inlineCode",{parentName:"li"},"6")," ",Object(r.b)("inlineCode",{parentName:"li"},"7")," ",Object(r.b)("inlineCode",{parentName:"li"},"8"),Object(r.b)("inlineCode",{parentName:"li"},"9")," ",Object(r.b)("inlineCode",{parentName:"li"},"10")," ",Object(r.b)("inlineCode",{parentName:"li"},"11")," ",Object(r.b)("inlineCode",{parentName:"li"},"12")," ",Object(r.b)("inlineCode",{parentName:"li"},"13")," ",Object(r.b)("inlineCode",{parentName:"li"},"14")," ",Object(r.b)("inlineCode",{parentName:"li"},"15")," ",Object(r.b)("inlineCode",{parentName:"li"},"16")," ",Object(r.b)("inlineCode",{parentName:"li"},"17")," ",Object(r.b)("inlineCode",{parentName:"li"},"18")," ",Object(r.b)("inlineCode",{parentName:"li"},"19")," ",Object(r.b)("inlineCode",{parentName:"li"},"20")," ",Object(r.b)("inlineCode",{parentName:"li"},"21")," ",Object(r.b)("inlineCode",{parentName:"li"},"22")," ",Object(r.b)("inlineCode",{parentName:"li"},"23"),Object(r.b)("inlineCode",{parentName:"li"},"24")," ",Object(r.b)("inlineCode",{parentName:"li"},"25")," ",Object(r.b)("inlineCode",{parentName:"li"},"26")," ",Object(r.b)("inlineCode",{parentName:"li"},"27")," ",Object(r.b)("inlineCode",{parentName:"li"},"28")," ",Object(r.b)("inlineCode",{parentName:"li"},"29")," ",Object(r.b)("inlineCode",{parentName:"li"},"30")," ",Object(r.b)("inlineCode",{parentName:"li"},"31"))))}c.isMDXComponent=!0},151:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return u}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function b(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=i.a.createContext({}),c=function(e){var t=i.a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):b(b({},t),e)),n},s=function(e){var t=c(e.components);return i.a.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,o=p(e,["components","mdxType","originalType","parentName"]),s=c(n),d=a,u=s["".concat(l,".").concat(d)]||s[d]||m[d]||r;return n?i.a.createElement(u,b(b({ref:t},o),{},{components:n})):i.a.createElement(u,b({ref:t},o))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=d;var b={};for(var p in t)hasOwnProperty.call(t,p)&&(b[p]=t[p]);b.originalType=e,b.mdxType="string"==typeof e?e:a,l[1]=b;for(var o=2;o<r;o++)l[o]=n[o];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);